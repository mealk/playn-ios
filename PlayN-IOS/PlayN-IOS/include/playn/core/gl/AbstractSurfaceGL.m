//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: playn/core/gl/AbstractSurfaceGL.java
//
//  Created by Thomas on 7/25/13.
//

#include "IOSFloatArray.h"
#include "IOSIntArray.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Math.h"
#include "java/util/ArrayList.h"
#include "java/util/List.h"
#include "playn/core/Asserts.h"
#include "playn/core/Image.h"
#include "playn/core/InternalTransform.h"
#include "playn/core/Layer.h"
#include "playn/core/Pattern.h"
#include "playn/core/Surface.h"
#include "playn/core/Tint.h"
#include "playn/core/gl/AbstractImageGL.h"
#include "playn/core/gl/AbstractSurfaceGL.h"
#include "playn/core/gl/GLContext.h"
#include "playn/core/gl/GLPattern.h"
#include "playn/core/gl/GLShader.h"
#include "playn/core/gl/LayerGL.h"
#include "pythagoras/f/FloatMath.h"
#include "pythagoras/f/MathUtil.h"
#include "pythagoras/f/Transform.h"

@implementation PlaynCoreGlAbstractSurfaceGL

@synthesize ctx = ctx_;
@synthesize transformStack = transformStack_;
@synthesize fillColor = fillColor_;
@synthesize tint = tint_;
@synthesize fillPattern = fillPattern_;
@synthesize shader = shader_;

- (id)initWithPlaynCoreGlGLContext:(PlaynCoreGlGLContext *)ctx {
  if ((self = [super init])) {
    transformStack_ = [[JavaUtilArrayList alloc] init];
    tint_ = PlaynCoreTint_NOOP_TINT;
    self.ctx = ctx;
    [((id<JavaUtilList>) nil_chk(transformStack_)) addWithId:[((PlaynCoreGlGLContext *) nil_chk(ctx)) createTransform]];
  }
  return self;
}

- (void)bindFramebuffer {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (id<PlaynCoreSurface>)clear {
  [self bindFramebuffer];
  [((PlaynCoreGlGLContext *) nil_chk(ctx_)) clearWithFloat:0 withFloat:0 withFloat:0 withFloat:0];
  return self;
}

- (id<PlaynCoreSurface>)drawImageWithPlaynCoreImage:(id<PlaynCoreImage>)image
                                          withFloat:(float)x
                                          withFloat:(float)y {
  return [self drawImageWithPlaynCoreImage:image withFloat:x withFloat:y withFloat:[((id<PlaynCoreImage>) nil_chk(image)) width] withFloat:[((id<PlaynCoreImage>) nil_chk(image)) height]];
}

- (id<PlaynCoreSurface>)drawImageWithPlaynCoreImage:(id<PlaynCoreImage>)image
                                          withFloat:(float)x
                                          withFloat:(float)y
                                          withFloat:(float)dw
                                          withFloat:(float)dh {
  [self bindFramebuffer];
  [((PlaynCoreGlAbstractImageGL *) image) drawWithPlaynCoreGlGLShader:shader_ withPlaynCoreInternalTransform:[self topTransform] withInt:tint_ withFloat:x withFloat:y withFloat:dw withFloat:dh];
  return self;
}

- (id<PlaynCoreSurface>)drawImageWithPlaynCoreImage:(id<PlaynCoreImage>)image
                                          withFloat:(float)dx
                                          withFloat:(float)dy
                                          withFloat:(float)dw
                                          withFloat:(float)dh
                                          withFloat:(float)sx
                                          withFloat:(float)sy
                                          withFloat:(float)sw
                                          withFloat:(float)sh {
  [self bindFramebuffer];
  [((PlaynCoreGlAbstractImageGL *) image) drawWithPlaynCoreGlGLShader:shader_ withPlaynCoreInternalTransform:[self topTransform] withInt:tint_ withFloat:dx withFloat:dy withFloat:dw withFloat:dh withFloat:sx withFloat:sy withFloat:sw withFloat:sh];
  return self;
}

- (id<PlaynCoreSurface>)drawImageCenteredWithPlaynCoreImage:(id<PlaynCoreImage>)img
                                                  withFloat:(float)x
                                                  withFloat:(float)y {
  return [self drawImageWithPlaynCoreImage:img withFloat:x - [((id<PlaynCoreImage>) nil_chk(img)) width] / 2 withFloat:y - [((id<PlaynCoreImage>) nil_chk(img)) height] / 2];
}

- (id<PlaynCoreSurface>)drawLayerWithPlaynCoreLayer:(id<PlaynCoreLayer>)layer {
  [self bindFramebuffer];
  [((PlaynCoreGlLayerGL *) layer) paintWithPlaynCoreInternalTransform:[self topTransform] withInt:tint_ withPlaynCoreGlGLShader:shader_];
  return self;
}

- (id<PlaynCoreSurface>)drawLineWithFloat:(float)x0
                                withFloat:(float)y0
                                withFloat:(float)x1
                                withFloat:(float)y1
                                withFloat:(float)width {
  [self bindFramebuffer];
  if (x1 < x0) {
    float temp = x0;
    x0 = x1;
    x1 = temp;
    temp = y0;
    y0 = y1;
    y1 = temp;
  }
  float dx = x1 - x0, dy = y1 - y0;
  float length = [PythagorasFFloatMath sqrtWithFloat:dx * dx + dy * dy];
  float wx = dx * (width / 2) / length;
  float wy = dy * (width / 2) / length;
  id<PlaynCoreInternalTransform> l = [((PlaynCoreGlGLContext *) nil_chk(ctx_)) createTransform];
  (void) [((id<PlaynCoreInternalTransform>) nil_chk(l)) setRotationWithFloat:[PythagorasFFloatMath atan2WithFloat:dy withFloat:dx]];
  (void) [((id<PlaynCoreInternalTransform>) nil_chk(l)) setTranslationWithFloat:x0 + wy withFloat:y0 - wx];
  (void) [((id<PlaynCoreInternalTransform>) nil_chk(l)) preConcatenateWithPlaynCoreInternalTransform:[self topTransform]];
  PlaynCoreGlGLShader *shader = [((PlaynCoreGlGLContext *) nil_chk(ctx_)) quadShaderWithPlaynCoreGlGLShader:self.shader];
  if (fillPattern_ != nil) {
    int tex = [fillPattern_ ensureTexture];
    if (tex > 0) {
      (void) [((PlaynCoreGlGLShader *) nil_chk(shader)) prepareTextureWithInt:tex withInt:tint_];
      [((PlaynCoreGlGLShader *) nil_chk(shader)) addQuadWithPlaynCoreInternalTransform:l withFloat:0 withFloat:0 withFloat:length withFloat:width withFloat:0 withFloat:0 withFloat:length / [fillPattern_ width] withFloat:width / [fillPattern_ height]];
    }
  }
  else {
    (void) [((PlaynCoreGlGLShader *) nil_chk(shader)) prepareColorWithInt:[PlaynCoreTint combineWithInt:fillColor_ withInt:tint_]];
    [((PlaynCoreGlGLShader *) nil_chk(shader)) addQuadWithPlaynCoreInternalTransform:l withFloat:0 withFloat:0 withFloat:length withFloat:width withFloat:0 withFloat:0 withFloat:1 withFloat:1];
  }
  return self;
}

- (id<PlaynCoreSurface>)fillRectWithFloat:(float)x
                                withFloat:(float)y
                                withFloat:(float)width
                                withFloat:(float)height {
  [self bindFramebuffer];
  PlaynCoreGlGLShader *shader = [((PlaynCoreGlGLContext *) nil_chk(ctx_)) quadShaderWithPlaynCoreGlGLShader:self.shader];
  if (fillPattern_ != nil) {
    int tex = [fillPattern_ ensureTexture];
    if (tex > 0) {
      (void) [((PlaynCoreGlGLShader *) nil_chk(shader)) prepareTextureWithInt:tex withInt:tint_];
      float tw = [fillPattern_ width], th = [fillPattern_ height], r = x + width, b = y + height;
      [((PlaynCoreGlGLShader *) nil_chk(shader)) addQuadWithPlaynCoreInternalTransform:[self topTransform] withFloat:x withFloat:y withFloat:x + width withFloat:y + height withFloat:x / tw withFloat:y / th withFloat:r / tw withFloat:b / th];
    }
  }
  else {
    (void) [((PlaynCoreGlGLShader *) nil_chk(shader)) prepareColorWithInt:[PlaynCoreTint combineWithInt:fillColor_ withInt:tint_]];
    [((PlaynCoreGlGLShader *) nil_chk(shader)) addQuadWithPlaynCoreInternalTransform:[self topTransform] withFloat:x withFloat:y withFloat:x + width withFloat:y + height withFloat:0 withFloat:0 withFloat:1 withFloat:1];
  }
  return self;
}

- (id<PlaynCoreSurface>)fillTrianglesWithFloatArray:(IOSFloatArray *)xys
                                       withIntArray:(IOSIntArray *)indices {
  [self bindFramebuffer];
  PlaynCoreGlGLShader *shader = [((PlaynCoreGlGLContext *) nil_chk(ctx_)) trisShaderWithPlaynCoreGlGLShader:self.shader];
  if (fillPattern_ != nil) {
    int tex = [fillPattern_ ensureTexture];
    if (tex > 0) {
      (void) [((PlaynCoreGlGLShader *) nil_chk(shader)) prepareTextureWithInt:tex withInt:tint_];
      [((PlaynCoreGlGLShader *) nil_chk(shader)) addTrianglesWithPlaynCoreInternalTransform:[self topTransform] withFloatArray:xys withFloat:[fillPattern_ width] withFloat:[fillPattern_ height] withIntArray:indices];
    }
  }
  else {
    (void) [((PlaynCoreGlGLShader *) nil_chk(shader)) prepareColorWithInt:[PlaynCoreTint combineWithInt:fillColor_ withInt:tint_]];
    [((PlaynCoreGlGLShader *) nil_chk(shader)) addTrianglesWithPlaynCoreInternalTransform:[self topTransform] withFloatArray:xys withFloat:1 withFloat:1 withIntArray:indices];
  }
  return self;
}

- (id<PlaynCoreSurface>)fillTrianglesWithFloatArray:(IOSFloatArray *)xys
                                     withFloatArray:(IOSFloatArray *)sxys
                                       withIntArray:(IOSIntArray *)indices {
  [self bindFramebuffer];
  if (fillPattern_ == nil) @throw [[JavaLangIllegalStateException alloc] initWithNSString:@"No fill pattern currently set"];
  int tex = [((PlaynCoreGlAbstractImageGL *) nil_chk(fillPattern_)) ensureTexture];
  if (tex > 0) {
    PlaynCoreGlGLShader *shader = [((PlaynCoreGlGLShader *) nil_chk([((PlaynCoreGlGLContext *) nil_chk(ctx_)) trisShaderWithPlaynCoreGlGLShader:self.shader])) prepareTextureWithInt:tex withInt:tint_];
    [((PlaynCoreGlGLShader *) nil_chk(shader)) addTrianglesWithPlaynCoreInternalTransform:[self topTransform] withFloatArray:xys withFloatArray:sxys withIntArray:indices];
  }
  return self;
}

- (id<PlaynCoreSurface>)restore {
  [PlaynCoreAsserts checkStateWithBOOL:[((id<JavaUtilList>) nil_chk(transformStack_)) size] > 1 withId:@"Unbalanced save/restore"];
  (void) [((id<JavaUtilList>) nil_chk(transformStack_)) removeWithInt:[((id<JavaUtilList>) nil_chk(transformStack_)) size] - 1];
  return self;
}

- (id<PlaynCoreSurface>)rotateWithFloat:(float)angle {
  float sr = (float) [JavaLangMath sinWithDouble:angle];
  float cr = (float) [JavaLangMath cosWithDouble:angle];
  (void) [self transformWithFloat:cr withFloat:sr withFloat:-sr withFloat:cr withFloat:0 withFloat:0];
  return self;
}

- (id<PlaynCoreSurface>)save {
  [((id<JavaUtilList>) nil_chk(transformStack_)) addWithId:[((id<PlaynCoreInternalTransform>) nil_chk([((PlaynCoreGlGLContext *) nil_chk(ctx_)) createTransform])) setWithPythagorasFTransform:[self topTransform]]];
  return self;
}

- (id<PlaynCoreSurface>)scale__WithFloat:(float)sx
                               withFloat:(float)sy {
  (void) [((id<PlaynCoreInternalTransform>) nil_chk([self topTransform])) scale__WithFloat:sx withFloat:sy];
  return self;
}

- (id<PlaynCoreSurface>)setTransformWithFloat:(float)m00
                                    withFloat:(float)m01
                                    withFloat:(float)m10
                                    withFloat:(float)m11
                                    withFloat:(float)tx
                                    withFloat:(float)ty {
  (void) [((id<PlaynCoreInternalTransform>) nil_chk([self topTransform])) setTransformWithFloat:m00 withFloat:m01 withFloat:m10 withFloat:m11 withFloat:tx withFloat:ty];
  return self;
}

- (id<PlaynCoreSurface>)setAlphaWithFloat:(float)alpha {
  int ialpha = (int) ((int) 0xFF * [PythagorasFMathUtil clampWithFloat:alpha withFloat:0 withFloat:1]);
  self.tint = (ialpha << 24) | (tint_ & (int) 0xFFFFFF);
  return self;
}

- (id<PlaynCoreSurface>)setTintWithInt:(int)tint {
  self.tint = tint;
  return self;
}

- (id<PlaynCoreSurface>)setFillColorWithInt:(int)color {
  self.fillColor = color;
  self.fillPattern = nil;
  return self;
}

- (id<PlaynCoreSurface>)setFillPatternWithPlaynCorePattern:(id<PlaynCorePattern>)pattern {
  [PlaynCoreAsserts checkArgumentWithBOOL:[(id) pattern conformsToProtocol: @protocol(PlaynCoreGlGLPattern)]];
  self.fillPattern = [((id<PlaynCoreGlGLPattern>) pattern) image];
  [((PlaynCoreGlAbstractImageGL *) nil_chk(self.fillPattern)) setRepeatWithBOOL:YES withBOOL:YES];
  return self;
}

- (id<PlaynCoreSurface>)setShaderWithPlaynCoreGlGLShader:(PlaynCoreGlGLShader *)shader {
  self.shader = shader;
  return self;
}

- (id<PlaynCoreSurface>)transformWithFloat:(float)m00
                                 withFloat:(float)m01
                                 withFloat:(float)m10
                                 withFloat:(float)m11
                                 withFloat:(float)tx
                                 withFloat:(float)ty {
  (void) [((id<PlaynCoreInternalTransform>) nil_chk([self topTransform])) concatenateWithFloat:m00 withFloat:m01 withFloat:m10 withFloat:m11 withFloat:tx withFloat:ty withFloat:0 withFloat:0];
  return self;
}

- (id<PlaynCoreSurface>)translateWithFloat:(float)x
                                 withFloat:(float)y {
  (void) [((id<PlaynCoreInternalTransform>) nil_chk([self topTransform])) translateWithFloat:x withFloat:y];
  return self;
}

- (id<PlaynCoreInternalTransform>)topTransform {
  return [((id<JavaUtilList>) nil_chk(transformStack_)) getWithInt:[((id<JavaUtilList>) nil_chk(transformStack_)) size] - 1];
}

- (float)height {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (float)width {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  PlaynCoreGlAbstractSurfaceGL *typedCopy = (PlaynCoreGlAbstractSurfaceGL *) copy;
  typedCopy.ctx = ctx_;
  typedCopy.transformStack = transformStack_;
  typedCopy.fillColor = fillColor_;
  typedCopy.tint = tint_;
  typedCopy.fillPattern = fillPattern_;
  typedCopy.shader = shader_;
}

@end
