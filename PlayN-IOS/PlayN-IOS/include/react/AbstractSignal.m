//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: react/AbstractSignal.java
//
//  Created by Thomas on 7/25/13.
//

#include "java/lang/Throwable.h"
#include "react/AbstractSignal.h"
#include "react/Connection.h"
#include "react/Cons.h"
#include "react/Function.h"
#include "react/MultiFailureException.h"
#include "react/Reactor.h"
#include "react/SignalView.h"
#include "react/Slot.h"

@implementation ReactAbstractSignal

- (id<ReactSignalView>)mapWithReactFunction:(id<ReactFunction>)func {
  ReactAbstractSignal *outer = self;
  return [[ReactAbstractSignal_$1 alloc] initWithReactAbstractSignal:outer withReactFunction:func];
}

- (id<ReactConnection>)connectWithReactSlot:(ReactSlot *)slot {
  ReactSlot *casted = (ReactSlot *) slot;
  return [self addConnectionWithId:casted];
}

- (void)disconnectWithReactSlot:(ReactSlot *)slot {
  ReactSlot *casted = (ReactSlot *) slot;
  [self removeConnectionWithId:casted];
}

- (void)notifyEmitWithId:(id)event {
  ReactCons *lners = [self prepareNotify];
  ReactMultiFailureException *error = nil;
  @try {
    for (ReactCons * cons = lners; cons != nil; cons = ((ReactCons *) nil_chk(cons)).next) {
      @try {
        [((ReactSlot *) nil_chk(((ReactCons *) nil_chk(cons)).listener)) onEmitWithId:event];
      }
      @catch (JavaLangThrowable *t) {
        if (error == nil) error = [[ReactMultiFailureException alloc] init];
        [((ReactMultiFailureException *) nil_chk(error)) addFailureWithJavaLangThrowable:t];
      }
      if (((ReactCons *) nil_chk(cons)).oneShot) [((ReactCons *) nil_chk(cons)) disconnect];
    }
  }
  @finally {
    [self finishNotifyWithReactCons:lners];
  }
  if (error != nil) [error trigger];
}

- (id)init {
  return [super init];
}

@end
@implementation ReactAbstractSignal_$1

@synthesize val$outer = val$outer_;
@synthesize val$func = val$func_;

- (id<ReactConnection>)connect {
  return [((ReactAbstractSignal *) nil_chk(val$outer_)) connectWithReactSlot:[[ReactAbstractSignal_$1_$1 alloc] initWithReactAbstractSignal_$1:self]];
}

- (id)initWithReactAbstractSignal:(ReactAbstractSignal *)capture$0
                withReactFunction:(id<ReactFunction>)capture$1 {
  if ((self = [super init])) {
    val$outer_ = capture$0;
    val$func_ = capture$1;
  }
  return self;
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  ReactAbstractSignal_$1 *typedCopy = (ReactAbstractSignal_$1 *) copy;
  typedCopy.val$outer = val$outer_;
  typedCopy.val$func = val$func_;
}

@end
@implementation ReactAbstractSignal_$1_$1

@synthesize this$0 = this$0_;

- (void)onEmitWithId:(id)value {
  [this$0_ notifyEmitWithId:[((id<ReactFunction>) nil_chk(this$0_.val$func)) applyWithId:value]];
}

- (id)initWithReactAbstractSignal_$1:(ReactAbstractSignal_$1 *)outer$ {
  if ((self = [super init])) {
    this$0_ = outer$;
  }
  return self;
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  ReactAbstractSignal_$1_$1 *typedCopy = (ReactAbstractSignal_$1_$1 *) copy;
  typedCopy.this$0 = this$0_;
}

@end
