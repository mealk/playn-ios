//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: react/AbstractValue.java
//
//  Created by Thomas on 7/25/13.
//

#include "IOSClass.h"
#include "java/lang/Error.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/Throwable.h"
#include "java/lang/UnsupportedOperationException.h"
#include "react/AbstractValue.h"
#include "react/Connection.h"
#include "react/Cons.h"
#include "react/Function.h"
#include "react/MultiFailureException.h"
#include "react/Reactor.h"
#include "react/ValueView.h"

@implementation ReactAbstractValue

- (id<ReactValueView>)mapWithReactFunction:(id<ReactFunction>)func {
  ReactAbstractValue *outer = self;
  return [[ReactAbstractValue_$1 alloc] initWithReactFunction:func withReactAbstractValue:outer];
}

- (id<ReactConnection>)connectWithReactValueView_Listener:(ReactValueView_Listener *)listener {
  ReactValueView_Listener *casted = (ReactValueView_Listener *) listener;
  return [self addConnectionWithId:casted];
}

- (id<ReactConnection>)connectNotifyWithReactValueView_Listener:(ReactValueView_Listener *)listener {
  id<ReactConnection> conn = [self connectWithReactValueView_Listener:listener];
  @try {
    [((ReactValueView_Listener *) nil_chk(listener)) onChangeWithId:[self get] withId:nil];
    return conn;
  }
  @catch (JavaLangRuntimeException *re) {
    [((id<ReactConnection>) nil_chk(conn)) disconnect];
    @throw re;
  }
  @catch (JavaLangError *e) {
    [((id<ReactConnection>) nil_chk(conn)) disconnect];
    @throw e;
  }
}

- (void)disconnectWithReactValueView_Listener:(ReactValueView_Listener *)listener {
  ReactValueView_Listener *casted = (ReactValueView_Listener *) listener;
  [self removeConnectionWithId:casted];
}

- (NSUInteger)hash {
  id value = [self get];
  return (value == nil) ? 0 : [nil_chk(value) hash];
}

- (BOOL)isEqual:(id)other {
  if (other == nil) return NO;
  if ([nil_chk(other) getClass] != [self getClass]) return NO;
  id value = [self get];
  id ovalue = [((ReactAbstractValue *) other) get];
  return [ReactReactor areEqualWithId:value withId:ovalue];
}

- (NSString *)description {
  NSString *cname = [[self getClass] getName];
  return [NSString stringWithFormat:@"%@(%@)", [((NSString *) nil_chk(cname)) substring:[((NSString *) nil_chk(cname)) lastIndexOfString:@"."] + 1], [self get]];
}

- (id)updateAndNotifyIfWithId:(id)value {
  return [self updateAndNotifyWithId:value withBOOL:NO];
}

- (id)updateAndNotifyWithId:(id)value {
  return [self updateAndNotifyWithId:value withBOOL:YES];
}

- (id)updateAndNotifyWithId:(id)value
                   withBOOL:(BOOL)force {
  [self checkMutate];
  id ovalue = [self updateLocalWithId:value];
  if (force || ![ReactReactor areEqualWithId:value withId:ovalue]) {
    [self emitChangeWithId:value withId:ovalue];
  }
  return ovalue;
}

- (void)emitChangeWithId:(id)value
                  withId:(id)ovalue {
  [self notifyChangeWithId:value withId:ovalue];
}

- (void)notifyChangeWithId:(id)value
                    withId:(id)ovalue {
  ReactCons *lners = [self prepareNotify];
  ReactMultiFailureException *error = nil;
  @try {
    for (ReactCons * cons = lners; cons != nil; cons = ((ReactCons *) nil_chk(cons)).next) {
      @try {
        [((ReactValueView_Listener *) nil_chk(((ReactCons *) nil_chk(cons)).listener)) onChangeWithId:value withId:ovalue];
      }
      @catch (JavaLangThrowable *t) {
        if (error == nil) error = [[ReactMultiFailureException alloc] init];
        [((ReactMultiFailureException *) nil_chk(error)) addFailureWithJavaLangThrowable:t];
      }
      if (((ReactCons *) nil_chk(cons)).oneShot) [((ReactCons *) nil_chk(cons)) disconnect];
    }
  }
  @finally {
    [self finishNotifyWithReactCons:lners];
  }
  if (error != nil) [error trigger];
}

- (id)updateLocalWithId:(id)value {
  @throw [[JavaLangUnsupportedOperationException alloc] init];
}

- (id)get {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)init {
  return [super init];
}

@end
@implementation ReactAbstractValue_$1

@synthesize val$func = val$func_;
@synthesize val$outer = val$outer_;

- (id)get {
  return [((id<ReactFunction>) nil_chk(val$func_)) applyWithId:[((ReactAbstractValue *) nil_chk(val$outer_)) get]];
}

- (id<ReactConnection>)connect {
  return [((ReactAbstractValue *) nil_chk(val$outer_)) connectWithReactValueView_Listener:[[ReactAbstractValue_$1_$1 alloc] initWithReactAbstractValue_$1:self]];
}

- (id)initWithReactFunction:(id<ReactFunction>)capture$0
     withReactAbstractValue:(ReactAbstractValue *)capture$1 {
  if ((self = [super init])) {
    val$func_ = capture$0;
    val$outer_ = capture$1;
  }
  return self;
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  ReactAbstractValue_$1 *typedCopy = (ReactAbstractValue_$1 *) copy;
  typedCopy.val$func = val$func_;
  typedCopy.val$outer = val$outer_;
}

@end
@implementation ReactAbstractValue_$1_$1

@synthesize this$0 = this$0_;

- (void)onChangeWithId:(id)value
                withId:(id)ovalue {
  [this$0_ notifyChangeWithId:[((id<ReactFunction>) nil_chk(this$0_.val$func)) applyWithId:value] withId:[((id<ReactFunction>) nil_chk(this$0_.val$func)) applyWithId:ovalue]];
}

- (id)initWithReactAbstractValue_$1:(ReactAbstractValue_$1 *)outer$ {
  if ((self = [super init])) {
    this$0_ = outer$;
  }
  return self;
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  ReactAbstractValue_$1_$1 *typedCopy = (ReactAbstractValue_$1_$1 *) copy;
  typedCopy.this$0 = this$0_;
}

@end
