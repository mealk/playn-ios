//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: pythagoras/d/CurveCrossingHelper.java
//
//  Created by Thomas on 7/25/13.
//

#include "IOSClass.h"
#include "IOSDoubleArray.h"
#include "IOSIntArray.h"
#include "IOSObjectArray.h"
#include "java/lang/Math.h"
#include "java/util/ArrayList.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"
#include "pythagoras/d/CurveCrossingHelper.h"
#include "pythagoras/d/GeometryUtil.h"
#include "pythagoras/d/IntersectPoint.h"
#include "pythagoras/d/PathIterator.h"

@implementation PythagorasDCurveCrossingHelper

@synthesize coords = coords_;
@synthesize rules = rules_;
@synthesize sizes = sizes_;
@synthesize rulesSizes = rulesSizes_;
@synthesize offsets = offsets_;
@synthesize isectPoints = isectPoints_;

- (id)initWithDoubleArray2:(IOSObjectArray *)coords
              withIntArray:(IOSIntArray *)sizes
             withIntArray2:(IOSObjectArray *)rules
              withIntArray:(IOSIntArray *)rulesSizes
             withIntArray2:(IOSObjectArray *)offsets {
  if ((self = [super init])) {
    isectPoints_ = [[JavaUtilArrayList alloc] init];
    self.coords = coords;
    self.rules = rules;
    self.sizes = sizes;
    self.rulesSizes = rulesSizes;
    self.offsets = offsets;
  }
  return self;
}

- (IOSObjectArray *)findCrossing {
  IOSDoubleArray *edge1 = [IOSDoubleArray arrayWithLength:8];
  IOSDoubleArray *edge2 = [IOSDoubleArray arrayWithLength:8];
  IOSDoubleArray *points = [IOSDoubleArray arrayWithLength:6];
  IOSDoubleArray *params = [IOSDoubleArray arrayWithLength:6];
  IOSDoubleArray *mp1 = [IOSDoubleArray arrayWithLength:2];
  IOSDoubleArray *cp1 = [IOSDoubleArray arrayWithLength:2];
  IOSDoubleArray *mp2 = [IOSDoubleArray arrayWithLength:2];
  IOSDoubleArray *cp2 = [IOSDoubleArray arrayWithLength:2];
  int rule1, rule2, endIndex1, endIndex2;
  int ipCount = 0;
  for (int i = 0; i < [((IOSIntArray *) nil_chk(rulesSizes_)) intAtIndex:0]; i++) {
    rule1 = [((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(rules_)) objectAtIndex:0])) intAtIndex:i];
    endIndex1 = [self currentEdgeWithInt:0 withInt:i withDoubleArray:edge1 withDoubleArray:mp1 withDoubleArray:cp1];
    for (int j = 0; j < [((IOSIntArray *) nil_chk(rulesSizes_)) intAtIndex:1]; j++) {
      ipCount = 0;
      rule2 = [((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(rules_)) objectAtIndex:1])) intAtIndex:j];
      endIndex2 = [self currentEdgeWithInt:1 withInt:j withDoubleArray:edge2 withDoubleArray:mp2 withDoubleArray:cp2];
      if (((rule1 == PythagorasDPathIterator_SEG_LINETO) || (rule1 == PythagorasDPathIterator_SEG_CLOSE)) && ((rule2 == PythagorasDPathIterator_SEG_LINETO) || (rule2 == PythagorasDPathIterator_SEG_CLOSE))) {
        ipCount = [PythagorasDGeometryUtil intersectLinesWithParamsWithDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:3] withDoubleArray:params];
        if (ipCount != 0) {
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:0]) = [PythagorasDGeometryUtil lineWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:2]];
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:1]) = [PythagorasDGeometryUtil lineWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:3]];
        }
      }
      else if (((rule1 == PythagorasDPathIterator_SEG_LINETO) || (rule1 == PythagorasDPathIterator_SEG_CLOSE)) && (rule2 == PythagorasDPathIterator_SEG_QUADTO)) {
        ipCount = [PythagorasDGeometryUtil intersectLineAndQuadWithDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:4] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:5] withDoubleArray:params];
        for (int k = 0; k < ipCount; k++) {
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:2 * k]) = [PythagorasDGeometryUtil lineWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:2]];
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:2 * k + 1]) = [PythagorasDGeometryUtil lineWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:3]];
        }
      }
      else if (rule1 == PythagorasDPathIterator_SEG_QUADTO && (rule2 == PythagorasDPathIterator_SEG_LINETO || rule2 == PythagorasDPathIterator_SEG_CLOSE)) {
        ipCount = [PythagorasDGeometryUtil intersectLineAndQuadWithDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:4] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:5] withDoubleArray:params];
        for (int k = 0; k < ipCount; k++) {
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:2 * k]) = [PythagorasDGeometryUtil lineWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k + 1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:2]];
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:2 * k + 1]) = [PythagorasDGeometryUtil lineWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k + 1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:3]];
        }
      }
      else if ((rule1 == PythagorasDPathIterator_SEG_CUBICTO) && ((rule2 == PythagorasDPathIterator_SEG_LINETO) || (rule2 == PythagorasDPathIterator_SEG_CLOSE))) {
        ipCount = [PythagorasDGeometryUtil intersectLineAndCubicWithDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:4] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:5] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:6] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:7] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:3] withDoubleArray:params];
        for (int k = 0; k < ipCount; k++) {
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:2 * k]) = [PythagorasDGeometryUtil lineWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k + 1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:2]];
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:2 * k + 1]) = [PythagorasDGeometryUtil lineWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k + 1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:3]];
        }
      }
      else if (((rule1 == PythagorasDPathIterator_SEG_LINETO) || (rule1 == PythagorasDPathIterator_SEG_CLOSE)) && (rule2 == PythagorasDPathIterator_SEG_CUBICTO)) {
        ipCount = [PythagorasDGeometryUtil intersectLineAndCubicWithDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:4] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:5] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:6] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:7] withDoubleArray:params];
        for (int k = 0; k < ipCount; k++) {
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:2 * k]) = [PythagorasDGeometryUtil lineWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:2]];
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:2 * k + 1]) = [PythagorasDGeometryUtil lineWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:3]];
        }
      }
      else if ((rule1 == PythagorasDPathIterator_SEG_QUADTO) && (rule2 == PythagorasDPathIterator_SEG_QUADTO)) {
        ipCount = [PythagorasDGeometryUtil intersectQuadsWithDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:4] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:5] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:4] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:5] withDoubleArray:params];
        for (int k = 0; k < ipCount; k++) {
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:2 * k]) = [PythagorasDGeometryUtil quadWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:4]];
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:2 * k + 1]) = [PythagorasDGeometryUtil quadWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:5]];
        }
      }
      else if ((rule1 == PythagorasDPathIterator_SEG_QUADTO) && (rule2 == PythagorasDPathIterator_SEG_CUBICTO)) {
        ipCount = [PythagorasDGeometryUtil intersectQuadAndCubicWithDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:4] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:5] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:4] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:5] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:6] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:7] withDoubleArray:params];
        for (int k = 0; k < ipCount; k++) {
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:2 * k]) = [PythagorasDGeometryUtil quadWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:4]];
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:2 * k + 1]) = [PythagorasDGeometryUtil quadWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:5]];
        }
      }
      else if ((rule1 == PythagorasDPathIterator_SEG_CUBICTO) && (rule2 == PythagorasDPathIterator_SEG_QUADTO)) {
        ipCount = [PythagorasDGeometryUtil intersectQuadAndCubicWithDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:4] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:5] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:4] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:5] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:6] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:7] withDoubleArray:params];
        for (int k = 0; k < ipCount; k++) {
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:2 * k]) = [PythagorasDGeometryUtil quadWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k + 1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:4]];
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:2 * k + 1]) = [PythagorasDGeometryUtil quadWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k + 1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:5]];
        }
      }
      else if ((rule1 == PythagorasDPathIterator_SEG_CUBICTO) && (rule2 == PythagorasDPathIterator_SEG_CUBICTO)) {
        ipCount = [PythagorasDGeometryUtil intersectCubicsWithDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:4] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:5] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:6] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:7] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:4] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:5] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:6] withDouble:[((IOSDoubleArray *) nil_chk(edge2)) doubleAtIndex:7] withDoubleArray:params];
        for (int k = 0; k < ipCount; k++) {
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:2 * k]) = [PythagorasDGeometryUtil cubicWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:4] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:6]];
          (*[((IOSDoubleArray *) nil_chk(points)) doubleRefAtIndex:2 * k + 1]) = [PythagorasDGeometryUtil cubicWithDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:5] withDouble:[((IOSDoubleArray *) nil_chk(edge1)) doubleAtIndex:7]];
        }
      }
      endIndex1 = i;
      endIndex2 = j;
      int begIndex1 = i - 1;
      int begIndex2 = j - 1;
      for (int k = 0; k < ipCount; k++) {
        PythagorasDIntersectPoint *ip = nil;
        if (![self containsPointWithDouble:[((IOSDoubleArray *) nil_chk(points)) doubleAtIndex:2 * k] withDouble:[((IOSDoubleArray *) nil_chk(points)) doubleAtIndex:2 * k + 1]]) {
          for (id<JavaUtilIterator> iter = [((id<JavaUtilList>) nil_chk(isectPoints_)) iterator]; [((id<JavaUtilIterator>) nil_chk(iter)) hasNext]; ) {
            ip = [((id<JavaUtilIterator>) nil_chk(iter)) next];
            if ((begIndex1 == [((PythagorasDIntersectPoint *) nil_chk(ip)) begIndexWithBOOL:YES]) && (endIndex1 == [((PythagorasDIntersectPoint *) nil_chk(ip)) endIndexWithBOOL:YES])) {
              if ([((PythagorasDIntersectPoint *) nil_chk(ip)) paramWithBOOL:YES] > [((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k]) {
                endIndex1 = -([((id<JavaUtilList>) nil_chk(isectPoints_)) indexOfWithId:ip] + 1);
                [((PythagorasDIntersectPoint *) nil_chk(ip)) setBegIndex1WithInt:-([((id<JavaUtilList>) nil_chk(isectPoints_)) size] + 1)];
              }
              else {
                begIndex1 = -([((id<JavaUtilList>) nil_chk(isectPoints_)) indexOfWithId:ip] + 1);
                [((PythagorasDIntersectPoint *) nil_chk(ip)) setEndIndex1WithInt:-([((id<JavaUtilList>) nil_chk(isectPoints_)) size] + 1)];
              }
            }
            if ((begIndex2 == [((PythagorasDIntersectPoint *) nil_chk(ip)) begIndexWithBOOL:NO]) && (endIndex2 == [((PythagorasDIntersectPoint *) nil_chk(ip)) endIndexWithBOOL:NO])) {
              if ([((PythagorasDIntersectPoint *) nil_chk(ip)) paramWithBOOL:NO] > [((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k + 1]) {
                endIndex2 = -([((id<JavaUtilList>) nil_chk(isectPoints_)) indexOfWithId:ip] + 1);
                [((PythagorasDIntersectPoint *) nil_chk(ip)) setBegIndex2WithInt:-([((id<JavaUtilList>) nil_chk(isectPoints_)) size] + 1)];
              }
              else {
                begIndex2 = -([((id<JavaUtilList>) nil_chk(isectPoints_)) indexOfWithId:ip] + 1);
                [((PythagorasDIntersectPoint *) nil_chk(ip)) setEndIndex2WithInt:-([((id<JavaUtilList>) nil_chk(isectPoints_)) size] + 1)];
              }
            }
          }
          if (rule1 == PythagorasDPathIterator_SEG_CLOSE) {
            rule1 = PythagorasDPathIterator_SEG_LINETO;
          }
          if (rule2 == PythagorasDPathIterator_SEG_CLOSE) {
            rule2 = PythagorasDPathIterator_SEG_LINETO;
          }
          [((id<JavaUtilList>) nil_chk(isectPoints_)) addWithId:[[PythagorasDIntersectPoint alloc] initWithInt:begIndex1 withInt:endIndex1 withInt:rule1 withInt:i withInt:begIndex2 withInt:endIndex2 withInt:rule2 withInt:j withDouble:[((IOSDoubleArray *) nil_chk(points)) doubleAtIndex:2 * k] withDouble:[((IOSDoubleArray *) nil_chk(points)) doubleAtIndex:2 * k + 1] withDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k] withDouble:[((IOSDoubleArray *) nil_chk(params)) doubleAtIndex:2 * k + 1]]];
        }
      }
    }
  }
  return [((id<JavaUtilList>) nil_chk(isectPoints_)) toArrayWithNSObjectArray:[IOSObjectArray arrayWithLength:[((id<JavaUtilList>) nil_chk(isectPoints_)) size] type:[IOSClass classWithClass:[PythagorasDIntersectPoint class]]]];
}

- (int)currentEdgeWithInt:(int)areaIndex
                  withInt:(int)index
          withDoubleArray:(IOSDoubleArray *)c
          withDoubleArray:(IOSDoubleArray *)mp
          withDoubleArray:(IOSDoubleArray *)cp {
  int endIndex = 0;
  switch ([((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(rules_)) objectAtIndex:areaIndex])) intAtIndex:index]) {
    case PythagorasDPathIterator_SEG_MOVETO:
    (*[((IOSDoubleArray *) nil_chk(cp)) doubleRefAtIndex:0]) = (*[((IOSDoubleArray *) nil_chk(mp)) doubleRefAtIndex:0]) = [((IOSDoubleArray *) nil_chk([((IOSObjectArray *) nil_chk(coords_)) objectAtIndex:areaIndex])) doubleAtIndex:[((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(offsets_)) objectAtIndex:areaIndex])) intAtIndex:index]];
    (*[((IOSDoubleArray *) nil_chk(cp)) doubleRefAtIndex:1]) = (*[((IOSDoubleArray *) nil_chk(mp)) doubleRefAtIndex:1]) = [((IOSDoubleArray *) nil_chk([((IOSObjectArray *) nil_chk(coords_)) objectAtIndex:areaIndex])) doubleAtIndex:[((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(offsets_)) objectAtIndex:areaIndex])) intAtIndex:index] + 1];
    break;
    case PythagorasDPathIterator_SEG_LINETO:
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:0]) = [((IOSDoubleArray *) nil_chk(cp)) doubleAtIndex:0];
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:1]) = [((IOSDoubleArray *) nil_chk(cp)) doubleAtIndex:1];
    (*[((IOSDoubleArray *) nil_chk(cp)) doubleRefAtIndex:0]) = (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:2]) = [((IOSDoubleArray *) nil_chk([((IOSObjectArray *) nil_chk(coords_)) objectAtIndex:areaIndex])) doubleAtIndex:[((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(offsets_)) objectAtIndex:areaIndex])) intAtIndex:index]];
    (*[((IOSDoubleArray *) nil_chk(cp)) doubleRefAtIndex:1]) = (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:3]) = [((IOSDoubleArray *) nil_chk([((IOSObjectArray *) nil_chk(coords_)) objectAtIndex:areaIndex])) doubleAtIndex:[((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(offsets_)) objectAtIndex:areaIndex])) intAtIndex:index] + 1];
    endIndex = 0;
    break;
    case PythagorasDPathIterator_SEG_QUADTO:
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:0]) = [((IOSDoubleArray *) nil_chk(cp)) doubleAtIndex:0];
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:1]) = [((IOSDoubleArray *) nil_chk(cp)) doubleAtIndex:1];
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:2]) = [((IOSDoubleArray *) nil_chk([((IOSObjectArray *) nil_chk(coords_)) objectAtIndex:areaIndex])) doubleAtIndex:[((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(offsets_)) objectAtIndex:areaIndex])) intAtIndex:index]];
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:3]) = [((IOSDoubleArray *) nil_chk([((IOSObjectArray *) nil_chk(coords_)) objectAtIndex:areaIndex])) doubleAtIndex:[((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(offsets_)) objectAtIndex:areaIndex])) intAtIndex:index] + 1];
    (*[((IOSDoubleArray *) nil_chk(cp)) doubleRefAtIndex:0]) = (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:4]) = [((IOSDoubleArray *) nil_chk([((IOSObjectArray *) nil_chk(coords_)) objectAtIndex:areaIndex])) doubleAtIndex:[((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(offsets_)) objectAtIndex:areaIndex])) intAtIndex:index] + 2];
    (*[((IOSDoubleArray *) nil_chk(cp)) doubleRefAtIndex:1]) = (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:5]) = [((IOSDoubleArray *) nil_chk([((IOSObjectArray *) nil_chk(coords_)) objectAtIndex:areaIndex])) doubleAtIndex:[((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(offsets_)) objectAtIndex:areaIndex])) intAtIndex:index] + 3];
    endIndex = 2;
    break;
    case PythagorasDPathIterator_SEG_CUBICTO:
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:0]) = [((IOSDoubleArray *) nil_chk(cp)) doubleAtIndex:0];
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:1]) = [((IOSDoubleArray *) nil_chk(cp)) doubleAtIndex:1];
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:2]) = [((IOSDoubleArray *) nil_chk([((IOSObjectArray *) nil_chk(coords_)) objectAtIndex:areaIndex])) doubleAtIndex:[((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(offsets_)) objectAtIndex:areaIndex])) intAtIndex:index]];
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:3]) = [((IOSDoubleArray *) nil_chk([((IOSObjectArray *) nil_chk(coords_)) objectAtIndex:areaIndex])) doubleAtIndex:[((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(offsets_)) objectAtIndex:areaIndex])) intAtIndex:index] + 1];
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:4]) = [((IOSDoubleArray *) nil_chk([((IOSObjectArray *) nil_chk(coords_)) objectAtIndex:areaIndex])) doubleAtIndex:[((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(offsets_)) objectAtIndex:areaIndex])) intAtIndex:index] + 2];
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:5]) = [((IOSDoubleArray *) nil_chk([((IOSObjectArray *) nil_chk(coords_)) objectAtIndex:areaIndex])) doubleAtIndex:[((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(offsets_)) objectAtIndex:areaIndex])) intAtIndex:index] + 3];
    (*[((IOSDoubleArray *) nil_chk(cp)) doubleRefAtIndex:0]) = (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:6]) = [((IOSDoubleArray *) nil_chk([((IOSObjectArray *) nil_chk(coords_)) objectAtIndex:areaIndex])) doubleAtIndex:[((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(offsets_)) objectAtIndex:areaIndex])) intAtIndex:index] + 4];
    (*[((IOSDoubleArray *) nil_chk(cp)) doubleRefAtIndex:1]) = (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:7]) = [((IOSDoubleArray *) nil_chk([((IOSObjectArray *) nil_chk(coords_)) objectAtIndex:areaIndex])) doubleAtIndex:[((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(offsets_)) objectAtIndex:areaIndex])) intAtIndex:index] + 5];
    endIndex = 4;
    break;
    case PythagorasDPathIterator_SEG_CLOSE:
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:0]) = [((IOSDoubleArray *) nil_chk(cp)) doubleAtIndex:0];
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:1]) = [((IOSDoubleArray *) nil_chk(cp)) doubleAtIndex:1];
    (*[((IOSDoubleArray *) nil_chk(cp)) doubleRefAtIndex:0]) = (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:2]) = [((IOSDoubleArray *) nil_chk(mp)) doubleAtIndex:0];
    (*[((IOSDoubleArray *) nil_chk(cp)) doubleRefAtIndex:1]) = (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:3]) = [((IOSDoubleArray *) nil_chk(mp)) doubleAtIndex:1];
    if ([((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(offsets_)) objectAtIndex:areaIndex])) intAtIndex:index] >= [((IOSIntArray *) nil_chk(sizes_)) intAtIndex:areaIndex]) {
      endIndex = -[((IOSIntArray *) nil_chk(sizes_)) intAtIndex:areaIndex];
    }
    else {
      endIndex = 0;
    }
    break;
  }
  return [((IOSIntArray *) nil_chk([((IOSObjectArray *) nil_chk(offsets_)) objectAtIndex:areaIndex])) intAtIndex:index] + endIndex;
}

- (BOOL)containsPointWithDouble:(double)x
                     withDouble:(double)y {
  PythagorasDIntersectPoint *ipoint;
  for (id<JavaUtilIterator> i = [((id<JavaUtilList>) nil_chk(isectPoints_)) iterator]; [((id<JavaUtilIterator>) nil_chk(i)) hasNext]; ) {
    ipoint = [((id<JavaUtilIterator>) nil_chk(i)) next];
    if (([JavaLangMath absWithDouble:[((PythagorasDIntersectPoint *) nil_chk(ipoint)) x] - x] < [JavaLangMath powWithDouble:10 withDouble:-6]) && ([JavaLangMath absWithDouble:[((PythagorasDIntersectPoint *) nil_chk(ipoint)) y] - y] < [JavaLangMath powWithDouble:10 withDouble:-6])) {
      return YES;
    }
  }
  return NO;
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  PythagorasDCurveCrossingHelper *typedCopy = (PythagorasDCurveCrossingHelper *) copy;
  typedCopy.coords = coords_;
  typedCopy.rules = rules_;
  typedCopy.sizes = sizes_;
  typedCopy.rulesSizes = rulesSizes_;
  typedCopy.offsets = offsets_;
  typedCopy.isectPoints = isectPoints_;
}

@end
