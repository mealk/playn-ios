//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: pythagoras/d/Area.java
//
//  Created by Thomas on 7/25/13.
//

#include "IOSClass.h"
#include "IOSDoubleArray.h"
#include "IOSIntArray.h"
#include "IOSObjectArray.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"
#include "java/util/NoSuchElementException.h"
#include "pythagoras/d/Area.h"
#include "pythagoras/d/Crossing.h"
#include "pythagoras/d/CrossingHelper.h"
#include "pythagoras/d/CurveCrossingHelper.h"
#include "pythagoras/d/FlatteningPathIterator.h"
#include "pythagoras/d/GeometryUtil.h"
#include "pythagoras/d/IPoint.h"
#include "pythagoras/d/IRectangle.h"
#include "pythagoras/d/IShape.h"
#include "pythagoras/d/IntersectPoint.h"
#include "pythagoras/d/PathIterator.h"
#include "pythagoras/d/Rectangle.h"
#include "pythagoras/d/Transform.h"
#include "pythagoras/d/Transforms.h"
#include "pythagoras/util/Platform.h"

@implementation PythagorasDArea

@synthesize coords = coords_;
@synthesize coordsSize = coordsSize_;
@synthesize rules = rules_;
@synthesize rulesSize = rulesSize_;
@synthesize offsets = offsets_;
@synthesize moveToCount = moveToCount_;
@synthesize isPolygonal_ = isPolygonal__;

- (id)init {
  if ((self = [super init])) {
    coords_ = [IOSDoubleArray arrayWithLength:20];
    coordsSize_ = 0;
    rules_ = [IOSIntArray arrayWithLength:10];
    rulesSize_ = 0;
    offsets_ = [IOSIntArray arrayWithLength:10];
    moveToCount_ = 0;
    isPolygonal__ = YES;
  }
  return self;
}

- (id)initWithPythagorasDIShape:(id<PythagorasDIShape>)s {
  if ((self = [super init])) {
    coords_ = [IOSDoubleArray arrayWithLength:20];
    coordsSize_ = 0;
    rules_ = [IOSIntArray arrayWithLength:10];
    rulesSize_ = 0;
    offsets_ = [IOSIntArray arrayWithLength:10];
    moveToCount_ = 0;
    isPolygonal__ = YES;
    IOSDoubleArray *segmentCoords = [IOSDoubleArray arrayWithLength:6];
    double lastMoveX = 0.0f;
    double lastMoveY = 0.0f;
    int rulesIndex = 0;
    int coordsIndex = 0;
    for (id<PythagorasDPathIterator> pi = [((id<PythagorasDIShape>) nil_chk(s)) pathIteratorWithPythagorasDTransform:nil]; ![((id<PythagorasDPathIterator>) nil_chk(pi)) isDone]; [((id<PythagorasDPathIterator>) nil_chk(pi)) next]) {
      coords_ = [PythagorasDArea adjustSizeWithDoubleArray:coords_ withInt:coordsIndex + 6];
      rules_ = [PythagorasDArea adjustSizeWithIntArray:rules_ withInt:rulesIndex + 1];
      offsets_ = [PythagorasDArea adjustSizeWithIntArray:offsets_ withInt:rulesIndex + 1];
      (*[((IOSIntArray *) nil_chk(rules_)) intRefAtIndex:rulesIndex]) = [((id<PythagorasDPathIterator>) nil_chk(pi)) currentSegmentWithDoubleArray:segmentCoords];
      (*[((IOSIntArray *) nil_chk(offsets_)) intRefAtIndex:rulesIndex]) = coordsIndex;
      switch ([((IOSIntArray *) nil_chk(rules_)) intAtIndex:rulesIndex]) {
        case PythagorasDPathIterator_SEG_MOVETO:
        (*[((IOSDoubleArray *) nil_chk(coords_)) doubleRefAtIndex:coordsIndex++]) = [((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:0];
        (*[((IOSDoubleArray *) nil_chk(coords_)) doubleRefAtIndex:coordsIndex++]) = [((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:1];
        lastMoveX = [((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:0];
        lastMoveY = [((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:1];
        ++moveToCount_;
        break;
        case PythagorasDPathIterator_SEG_LINETO:
        if (([((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:0] != lastMoveX) || ([((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:1] != lastMoveY)) {
          (*[((IOSDoubleArray *) nil_chk(coords_)) doubleRefAtIndex:coordsIndex++]) = [((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:0];
          (*[((IOSDoubleArray *) nil_chk(coords_)) doubleRefAtIndex:coordsIndex++]) = [((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:1];
        }
        else {
          --rulesIndex;
        }
        break;
        case PythagorasDPathIterator_SEG_QUADTO:
        [JavaLangSystem arraycopyWithId:segmentCoords withInt:0 withId:coords_ withInt:coordsIndex withInt:4];
        coordsIndex += 4;
        isPolygonal__ = NO;
        break;
        case PythagorasDPathIterator_SEG_CUBICTO:
        [JavaLangSystem arraycopyWithId:segmentCoords withInt:0 withId:coords_ withInt:coordsIndex withInt:6];
        coordsIndex += 6;
        isPolygonal__ = NO;
        break;
        case PythagorasDPathIterator_SEG_CLOSE:
        break;
      }
      ++rulesIndex;
    }
    if ((rulesIndex != 0) && ([((IOSIntArray *) nil_chk(rules_)) intAtIndex:rulesIndex - 1] != PythagorasDPathIterator_SEG_CLOSE)) {
      (*[((IOSIntArray *) nil_chk(rules_)) intRefAtIndex:rulesIndex]) = PythagorasDPathIterator_SEG_CLOSE;
      (*[((IOSIntArray *) nil_chk(offsets_)) intRefAtIndex:rulesIndex]) = coordsSize_;
    }
    rulesSize_ = rulesIndex;
    coordsSize_ = coordsIndex;
  }
  return self;
}

- (BOOL)isPolygonal {
  return isPolygonal__;
}

- (BOOL)isRectangular {
  return (isPolygonal__) && (rulesSize_ <= 5) && (coordsSize_ <= 8) && ([((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:1] == [((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:3]) && ([((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:7] == [((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:5]) && ([((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:0] == [((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:6]) && ([((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2] == [((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:4]);
}

- (BOOL)isSingular {
  return (moveToCount_ <= 1);
}

- (void)reset {
  coordsSize_ = 0;
  rulesSize_ = 0;
}

- (void)transformWithPythagorasDTransform:(id<PythagorasDTransform>)t {
  [self copy__WithPythagorasDArea:[[PythagorasDArea alloc] initWithPythagorasDIShape:[PythagorasDTransforms createTransformedShapeWithPythagorasDTransform:t withPythagorasDIShape:self]] withPythagorasDArea:self];
}

- (PythagorasDArea *)createTransformedAreaWithPythagorasDTransform:(id<PythagorasDTransform>)t {
  return [[PythagorasDArea alloc] initWithPythagorasDIShape:[PythagorasDTransforms createTransformedShapeWithPythagorasDTransform:t withPythagorasDIShape:self]];
}

- (void)addWithPythagorasDArea:(PythagorasDArea *)area {
  if (area == nil || [((PythagorasDArea *) nil_chk(area)) isEmpty]) {
    return;
  }
  else if ([self isEmpty]) {
    [self copy__WithPythagorasDArea:area withPythagorasDArea:self];
    return;
  }
  if ([self isPolygonal] && [((PythagorasDArea *) nil_chk(area)) isPolygonal]) {
    [self addPolygonWithPythagorasDArea:area];
  }
  else {
    [self addCurvePolygonWithPythagorasDArea:area];
  }
  if ([self areaBoundsSquare] < [PythagorasDGeometryUtil EPSILON]) {
    [self reset];
  }
}

- (void)intersectWithPythagorasDArea:(PythagorasDArea *)area {
  if (area == nil) {
    return;
  }
  else if ([self isEmpty] || [area isEmpty]) {
    [self reset];
    return;
  }
  if ([self isPolygonal] && [((PythagorasDArea *) nil_chk(area)) isPolygonal]) {
    [self intersectPolygonWithPythagorasDArea:area];
  }
  else {
    [self intersectCurvePolygonWithPythagorasDArea:area];
  }
  if ([self areaBoundsSquare] < [PythagorasDGeometryUtil EPSILON]) {
    [self reset];
  }
}

- (void)subtractWithPythagorasDArea:(PythagorasDArea *)area {
  if (area == nil || [self isEmpty] || [((PythagorasDArea *) nil_chk(area)) isEmpty]) {
    return;
  }
  if ([self isPolygonal] && [((PythagorasDArea *) nil_chk(area)) isPolygonal]) {
    [self subtractPolygonWithPythagorasDArea:area];
  }
  else {
    [self subtractCurvePolygonWithPythagorasDArea:area];
  }
  if ([self areaBoundsSquare] < [PythagorasDGeometryUtil EPSILON]) {
    [self reset];
  }
}

- (void)exclusiveOrWithPythagorasDArea:(PythagorasDArea *)area {
  PythagorasDArea *a = [self clone];
  [((PythagorasDArea *) nil_chk(a)) intersectWithPythagorasDArea:area];
  [self addWithPythagorasDArea:area];
  [self subtractWithPythagorasDArea:a];
}

- (BOOL)isEmpty {
  return (rulesSize_ == 0) && (coordsSize_ == 0);
}

- (BOOL)containsWithDouble:(double)x
                withDouble:(double)y {
  return ![self isEmpty] && [self containsExactWithDouble:x withDouble:y] > 0;
}

- (BOOL)containsWithDouble:(double)x
                withDouble:(double)y
                withDouble:(double)width
                withDouble:(double)height {
  int crossCount = [PythagorasDCrossing intersectPathWithPythagorasDPathIterator:[self pathIteratorWithPythagorasDTransform:nil] withDouble:x withDouble:y withDouble:width withDouble:height];
  return crossCount != PythagorasDCrossing_CROSSING && [PythagorasDCrossing isInsideEvenOddWithInt:crossCount];
}

- (BOOL)containsWithPythagorasDIPoint:(id<PythagorasDIPoint>)p {
  return [self containsWithDouble:[((id<PythagorasDIPoint>) nil_chk(p)) x] withDouble:[((id<PythagorasDIPoint>) nil_chk(p)) y]];
}

- (BOOL)containsWithPythagorasDIRectangle:(id<PythagorasDIRectangle>)r {
  return [self containsWithDouble:[((id<PythagorasDIRectangle>) nil_chk(r)) x] withDouble:[((id<PythagorasDIRectangle>) nil_chk(r)) y] withDouble:[((id<PythagorasDIRectangle>) nil_chk(r)) width] withDouble:[((id<PythagorasDIRectangle>) nil_chk(r)) height]];
}

- (BOOL)intersectsWithDouble:(double)x
                  withDouble:(double)y
                  withDouble:(double)width
                  withDouble:(double)height {
  if ((width <= 0.0f) || (height <= 0.0f)) {
    return NO;
  }
  else if (![((PythagorasDRectangle *) nil_chk([self bounds])) intersectsWithDouble:x withDouble:y withDouble:width withDouble:height]) {
    return NO;
  }
  int crossCount = [PythagorasDCrossing intersectShapeWithPythagorasDIShape:self withDouble:x withDouble:y withDouble:width withDouble:height];
  return [PythagorasDCrossing isInsideEvenOddWithInt:crossCount];
}

- (BOOL)intersectsWithPythagorasDIRectangle:(id<PythagorasDIRectangle>)r {
  return [self intersectsWithDouble:[((id<PythagorasDIRectangle>) nil_chk(r)) x] withDouble:[((id<PythagorasDIRectangle>) nil_chk(r)) y] withDouble:[((id<PythagorasDIRectangle>) nil_chk(r)) width] withDouble:[((id<PythagorasDIRectangle>) nil_chk(r)) height]];
}

- (PythagorasDRectangle *)bounds {
  return [self boundsWithPythagorasDRectangle:[[PythagorasDRectangle alloc] init]];
}

- (PythagorasDRectangle *)boundsWithPythagorasDRectangle:(PythagorasDRectangle *)target {
  double maxX = [((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:0], maxY = [((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:1];
  double minX = [((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:0], minY = [((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:1];
  for (int i = 0; i < coordsSize_; ) {
    minX = [JavaLangMath minWithDouble:minX withDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:i]];
    maxX = [JavaLangMath maxWithDouble:maxX withDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:i++]];
    minY = [JavaLangMath minWithDouble:minY withDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:i]];
    maxY = [JavaLangMath maxWithDouble:maxY withDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:i++]];
  }
  return [[PythagorasDRectangle alloc] initWithDouble:minX withDouble:minY withDouble:maxX - minX withDouble:maxY - minY];
}

- (id<PythagorasDPathIterator>)pathIteratorWithPythagorasDTransform:(id<PythagorasDTransform>)t {
  return [[PythagorasDArea_AreaPathIterator alloc] initWithPythagorasDArea:self withPythagorasDTransform:t];
}

- (id<PythagorasDPathIterator>)pathIteratorWithPythagorasDTransform:(id<PythagorasDTransform>)t
                                                         withDouble:(double)flatness {
  return [[PythagorasDFlatteningPathIterator alloc] initWithPythagorasDPathIterator:[self pathIteratorWithPythagorasDTransform:t] withDouble:flatness];
}

- (BOOL)isEqual:(id)obj {
  if (self == obj) {
    return YES;
  }
  else if (!([obj isKindOfClass:[PythagorasDArea class]])) {
    return NO;
  }
  PythagorasDArea *area = [self clone];
  [((PythagorasDArea *) nil_chk(area)) subtractWithPythagorasDArea:(PythagorasDArea *) obj];
  return [((PythagorasDArea *) nil_chk(area)) isEmpty];
}

- (PythagorasDArea *)clone {
  PythagorasDArea *area = [[PythagorasDArea alloc] init];
  [self copy__WithPythagorasDArea:self withPythagorasDArea:area];
  return area;
}

- (void)addCurvePolygonWithPythagorasDArea:(PythagorasDArea *)area {
  PythagorasDCurveCrossingHelper *crossHelper = [[PythagorasDCurveCrossingHelper alloc] initWithDoubleArray2:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasDArea *) nil_chk(area)).coords } count:2 type:[IOSDoubleArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasDArea *) nil_chk(area)).coordsSize } count:2] withIntArray2:[IOSObjectArray arrayWithObjects:(id[]){ rules_, ((PythagorasDArea *) nil_chk(area)).rules } count:2 type:[IOSIntArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ rulesSize_, ((PythagorasDArea *) nil_chk(area)).rulesSize } count:2] withIntArray2:[IOSObjectArray arrayWithObjects:(id[]){ offsets_, ((PythagorasDArea *) nil_chk(area)).offsets } count:2 type:[IOSIntArray iosClass]]];
  IOSObjectArray *intersectPoints = [((PythagorasDCurveCrossingHelper *) nil_chk(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) nil_chk(intersectPoints)) count] == 0) {
    if ([((PythagorasDArea *) nil_chk(area)) containsWithPythagorasDIRectangle:[self bounds]]) {
      [self copy__WithPythagorasDArea:area withPythagorasDArea:self];
    }
    else if (![self containsWithPythagorasDIRectangle:[((PythagorasDArea *) nil_chk(area)) bounds]]) {
      coords_ = [PythagorasDArea adjustSizeWithDoubleArray:coords_ withInt:coordsSize_ + ((PythagorasDArea *) nil_chk(area)).coordsSize];
      [JavaLangSystem arraycopyWithId:((PythagorasDArea *) nil_chk(area)).coords withInt:0 withId:coords_ withInt:coordsSize_ withInt:((PythagorasDArea *) nil_chk(area)).coordsSize];
      coordsSize_ += ((PythagorasDArea *) nil_chk(area)).coordsSize;
      rules_ = [PythagorasDArea adjustSizeWithIntArray:rules_ withInt:rulesSize_ + ((PythagorasDArea *) nil_chk(area)).rulesSize];
      [JavaLangSystem arraycopyWithId:((PythagorasDArea *) nil_chk(area)).rules withInt:0 withId:rules_ withInt:rulesSize_ withInt:((PythagorasDArea *) nil_chk(area)).rulesSize];
      rulesSize_ += ((PythagorasDArea *) nil_chk(area)).rulesSize;
      offsets_ = [PythagorasDArea adjustSizeWithIntArray:offsets_ withInt:rulesSize_ + ((PythagorasDArea *) nil_chk(area)).rulesSize];
      [JavaLangSystem arraycopyWithId:((PythagorasDArea *) nil_chk(area)).offsets withInt:0 withId:offsets_ withInt:rulesSize_ withInt:((PythagorasDArea *) nil_chk(area)).rulesSize];
    }
    return;
  }
  IOSDoubleArray *resultCoords = [IOSDoubleArray arrayWithLength:coordsSize_ + ((PythagorasDArea *) nil_chk(area)).coordsSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultRules = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasDArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultOffsets = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasDArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasDIntersectPoint *point = [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0];
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_MOVETO;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
  do {
    (*[((IOSDoubleArray *) nil_chk(resultCoords)) doubleRefAtIndex:resultCoordPos++]) = [((PythagorasDIntersectPoint *) nil_chk(point)) x];
    (*[((IOSDoubleArray *) nil_chk(resultCoords)) doubleRefAtIndex:resultCoordPos++]) = [((PythagorasDIntersectPoint *) nil_chk(point)) y];
    int curIndex = [((PythagorasDIntersectPoint *) nil_chk(point)) endIndexWithBOOL:YES];
    if (curIndex < 0) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasDArea *) nil_chk(area)) containsExactWithDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex] withDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = NO;
    }
    else {
      isCurrentArea = YES;
    }
    PythagorasDIntersectPoint *nextPoint = [self nextIntersectPointWithPythagorasDIntersectPointArray:intersectPoints withPythagorasDIntersectPoint:point withBOOL:isCurrentArea];
    IOSDoubleArray *coords = (isCurrentArea) ? self.coords : ((PythagorasDArea *) nil_chk(area)).coords;
    IOSIntArray *offsets = (isCurrentArea) ? self.offsets : ((PythagorasDArea *) nil_chk(area)).offsets;
    IOSIntArray *rules = (isCurrentArea) ? self.rules : ((PythagorasDArea *) nil_chk(area)).rules;
    int offset = [((PythagorasDIntersectPoint *) nil_chk(point)) ruleIndexWithBOOL:isCurrentArea];
    BOOL isCopyUntilZero = NO;
    if (([((PythagorasDIntersectPoint *) nil_chk(point)) ruleIndexWithBOOL:isCurrentArea] > [((PythagorasDIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea])) {
      int rulesSize = (isCurrentArea) ? self.rulesSize : ((PythagorasDArea *) nil_chk(area)).rulesSize;
      resultCoordPos = [self includeCoordsAndRulesWithInt:offset + 1 withInt:rulesSize withIntArray:rules withIntArray:offsets withIntArray:resultRules withIntArray:resultOffsets withDoubleArray:resultCoords withDoubleArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasDIntersectPoint:point withBOOL:isCurrentArea withBOOL:NO withInt:0];
      resultRulesPos += rulesSize - offset - 1;
      offset = 1;
      isCopyUntilZero = YES;
    }
    int length = [((PythagorasDIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea] - offset + 1;
    if (isCopyUntilZero) {
      offset = 0;
    }
    resultCoordPos = [self includeCoordsAndRulesWithInt:offset withInt:length withIntArray:rules withIntArray:offsets withIntArray:resultRules withIntArray:resultOffsets withDoubleArray:resultCoords withDoubleArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasDIntersectPoint:point withBOOL:isCurrentArea withBOOL:YES withInt:0];
    resultRulesPos += length - offset;
    point = nextPoint;
  }
  while (point != [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0]);
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos++]) = PythagorasDPathIterator_SEG_CLOSE;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos - 1]) = resultCoordPos;
  self.coords = resultCoords;
  self.rules = resultRules;
  self.offsets = resultOffsets;
  self.coordsSize = resultCoordPos;
  self.rulesSize = resultRulesPos;
}

- (void)addPolygonWithPythagorasDArea:(PythagorasDArea *)area {
  PythagorasDCrossingHelper *crossHelper = [[PythagorasDCrossingHelper alloc] initWithDoubleArray2:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasDArea *) nil_chk(area)).coords } count:2 type:[IOSDoubleArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasDArea *) nil_chk(area)).coordsSize } count:2]];
  IOSObjectArray *intersectPoints = [((PythagorasDCrossingHelper *) nil_chk(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) nil_chk(intersectPoints)) count] == 0) {
    if ([((PythagorasDArea *) nil_chk(area)) containsWithPythagorasDIRectangle:[self bounds]]) {
      [self copy__WithPythagorasDArea:area withPythagorasDArea:self];
    }
    else if (![self containsWithPythagorasDIRectangle:[((PythagorasDArea *) nil_chk(area)) bounds]]) {
      coords_ = [PythagorasDArea adjustSizeWithDoubleArray:coords_ withInt:coordsSize_ + ((PythagorasDArea *) nil_chk(area)).coordsSize];
      [JavaLangSystem arraycopyWithId:((PythagorasDArea *) nil_chk(area)).coords withInt:0 withId:coords_ withInt:coordsSize_ withInt:((PythagorasDArea *) nil_chk(area)).coordsSize];
      coordsSize_ += ((PythagorasDArea *) nil_chk(area)).coordsSize;
      rules_ = [PythagorasDArea adjustSizeWithIntArray:rules_ withInt:rulesSize_ + ((PythagorasDArea *) nil_chk(area)).rulesSize];
      [JavaLangSystem arraycopyWithId:((PythagorasDArea *) nil_chk(area)).rules withInt:0 withId:rules_ withInt:rulesSize_ withInt:((PythagorasDArea *) nil_chk(area)).rulesSize];
      rulesSize_ += ((PythagorasDArea *) nil_chk(area)).rulesSize;
      offsets_ = [PythagorasDArea adjustSizeWithIntArray:offsets_ withInt:rulesSize_ + ((PythagorasDArea *) nil_chk(area)).rulesSize];
      [JavaLangSystem arraycopyWithId:((PythagorasDArea *) nil_chk(area)).offsets withInt:0 withId:offsets_ withInt:rulesSize_ withInt:((PythagorasDArea *) nil_chk(area)).rulesSize];
    }
    return;
  }
  IOSDoubleArray *resultCoords = [IOSDoubleArray arrayWithLength:coordsSize_ + ((PythagorasDArea *) nil_chk(area)).coordsSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultRules = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasDArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultOffsets = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasDArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasDIntersectPoint *point = [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0];
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_MOVETO;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
  do {
    (*[((IOSDoubleArray *) nil_chk(resultCoords)) doubleRefAtIndex:resultCoordPos++]) = [((PythagorasDIntersectPoint *) nil_chk(point)) x];
    (*[((IOSDoubleArray *) nil_chk(resultCoords)) doubleRefAtIndex:resultCoordPos++]) = [((PythagorasDIntersectPoint *) nil_chk(point)) y];
    (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_LINETO;
    (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos - 2;
    int curIndex = [((PythagorasDIntersectPoint *) nil_chk(point)) endIndexWithBOOL:YES];
    if (curIndex < 0) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasDArea *) nil_chk(area)) containsExactWithDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex] withDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = NO;
    }
    else {
      isCurrentArea = YES;
    }
    PythagorasDIntersectPoint *nextPoint = [self nextIntersectPointWithPythagorasDIntersectPointArray:intersectPoints withPythagorasDIntersectPoint:point withBOOL:isCurrentArea];
    IOSDoubleArray *coords = (isCurrentArea) ? self.coords : ((PythagorasDArea *) nil_chk(area)).coords;
    int offset = 2 * [((PythagorasDIntersectPoint *) nil_chk(point)) endIndexWithBOOL:isCurrentArea];
    if ((offset >= 0) && ([((PythagorasDIntersectPoint *) nil_chk(nextPoint)) begIndexWithBOOL:isCurrentArea] < [((PythagorasDIntersectPoint *) nil_chk(point)) endIndexWithBOOL:isCurrentArea])) {
      int coordSize = (isCurrentArea) ? self.coordsSize : ((PythagorasDArea *) nil_chk(area)).coordsSize;
      int length = coordSize - offset;
      [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      for (int i = 0; i < length / 2; i++) {
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_LINETO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
        resultCoordPos += 2;
      }
      offset = 0;
    }
    if (offset >= 0) {
      int length = 2 * [((PythagorasDIntersectPoint *) nil_chk(nextPoint)) begIndexWithBOOL:isCurrentArea] - offset + 2;
      [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      for (int i = 0; i < length / 2; i++) {
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_LINETO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
        resultCoordPos += 2;
      }
    }
    point = nextPoint;
  }
  while (point != [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0]);
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos - 1]) = PythagorasDPathIterator_SEG_CLOSE;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos - 1]) = resultCoordPos;
  coords_ = resultCoords;
  rules_ = resultRules;
  offsets_ = resultOffsets;
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (void)intersectCurvePolygonWithPythagorasDArea:(PythagorasDArea *)area {
  PythagorasDCurveCrossingHelper *crossHelper = [[PythagorasDCurveCrossingHelper alloc] initWithDoubleArray2:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasDArea *) nil_chk(area)).coords } count:2 type:[IOSDoubleArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasDArea *) nil_chk(area)).coordsSize } count:2] withIntArray2:[IOSObjectArray arrayWithObjects:(id[]){ rules_, ((PythagorasDArea *) nil_chk(area)).rules } count:2 type:[IOSIntArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ rulesSize_, ((PythagorasDArea *) nil_chk(area)).rulesSize } count:2] withIntArray2:[IOSObjectArray arrayWithObjects:(id[]){ offsets_, ((PythagorasDArea *) nil_chk(area)).offsets } count:2 type:[IOSIntArray iosClass]]];
  IOSObjectArray *intersectPoints = [((PythagorasDCurveCrossingHelper *) nil_chk(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) nil_chk(intersectPoints)) count] == 0) {
    if ([self containsWithPythagorasDIRectangle:[((PythagorasDArea *) nil_chk(area)) bounds]]) {
      [self copy__WithPythagorasDArea:area withPythagorasDArea:self];
    }
    else if (![((PythagorasDArea *) nil_chk(area)) containsWithPythagorasDIRectangle:[self bounds]]) {
      [self reset];
    }
    return;
  }
  IOSDoubleArray *resultCoords = [IOSDoubleArray arrayWithLength:coordsSize_ + ((PythagorasDArea *) nil_chk(area)).coordsSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultRules = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasDArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultOffsets = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasDArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasDIntersectPoint *point = [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0];
  PythagorasDIntersectPoint *nextPoint = [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0];
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_MOVETO;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
  do {
    (*[((IOSDoubleArray *) nil_chk(resultCoords)) doubleRefAtIndex:resultCoordPos++]) = [((PythagorasDIntersectPoint *) nil_chk(point)) x];
    (*[((IOSDoubleArray *) nil_chk(resultCoords)) doubleRefAtIndex:resultCoordPos++]) = [((PythagorasDIntersectPoint *) nil_chk(point)) y];
    int curIndex = [((PythagorasDIntersectPoint *) nil_chk(point)) endIndexWithBOOL:YES];
    if ((curIndex < 0) || ([((PythagorasDArea *) nil_chk(area)) containsExactWithDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex] withDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex + 1]] == 0)) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasDArea *) nil_chk(area)) containsExactWithDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex] withDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = YES;
    }
    else {
      isCurrentArea = NO;
    }
    nextPoint = [self nextIntersectPointWithPythagorasDIntersectPointArray:intersectPoints withPythagorasDIntersectPoint:point withBOOL:isCurrentArea];
    IOSDoubleArray *coords = (isCurrentArea) ? self.coords : ((PythagorasDArea *) nil_chk(area)).coords;
    IOSIntArray *offsets = (isCurrentArea) ? self.offsets : ((PythagorasDArea *) nil_chk(area)).offsets;
    IOSIntArray *rules = (isCurrentArea) ? self.rules : ((PythagorasDArea *) nil_chk(area)).rules;
    int offset = [((PythagorasDIntersectPoint *) nil_chk(point)) ruleIndexWithBOOL:isCurrentArea];
    BOOL isCopyUntilZero = NO;
    if ([((PythagorasDIntersectPoint *) nil_chk(point)) ruleIndexWithBOOL:isCurrentArea] > [((PythagorasDIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea]) {
      int rulesSize = (isCurrentArea) ? self.rulesSize : ((PythagorasDArea *) nil_chk(area)).rulesSize;
      resultCoordPos = [self includeCoordsAndRulesWithInt:offset + 1 withInt:rulesSize withIntArray:rules withIntArray:offsets withIntArray:resultRules withIntArray:resultOffsets withDoubleArray:resultCoords withDoubleArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasDIntersectPoint:point withBOOL:isCurrentArea withBOOL:NO withInt:1];
      resultRulesPos += rulesSize - offset - 1;
      offset = 1;
      isCopyUntilZero = YES;
    }
    int length = [((PythagorasDIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea] - offset + 1;
    if (isCopyUntilZero) {
      offset = 0;
      isCopyUntilZero = NO;
    }
    if ((length == offset) && ([((PythagorasDIntersectPoint *) nil_chk(nextPoint)) ruleWithBOOL:isCurrentArea] != PythagorasDPathIterator_SEG_LINETO) && ([((PythagorasDIntersectPoint *) nil_chk(nextPoint)) ruleWithBOOL:isCurrentArea] != PythagorasDPathIterator_SEG_CLOSE) && ([((PythagorasDIntersectPoint *) nil_chk(point)) ruleWithBOOL:isCurrentArea] != PythagorasDPathIterator_SEG_LINETO) && ([((PythagorasDIntersectPoint *) nil_chk(point)) ruleWithBOOL:isCurrentArea] != PythagorasDPathIterator_SEG_CLOSE)) {
      isCopyUntilZero = YES;
      length++;
    }
    resultCoordPos = [self includeCoordsAndRulesWithInt:offset withInt:length withIntArray:rules withIntArray:offsets withIntArray:resultRules withIntArray:resultOffsets withDoubleArray:resultCoords withDoubleArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasDIntersectPoint:nextPoint withBOOL:isCurrentArea withBOOL:YES withInt:1];
    resultRulesPos = ((length <= offset) || (isCopyUntilZero)) ? resultRulesPos + 1 : resultRulesPos + length;
    point = nextPoint;
  }
  while (point != [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0]);
  if ([((IOSIntArray *) nil_chk(resultRules)) intAtIndex:resultRulesPos - 1] == PythagorasDPathIterator_SEG_LINETO) {
    (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos - 1]) = PythagorasDPathIterator_SEG_CLOSE;
  }
  else {
    (*[((IOSDoubleArray *) nil_chk(resultCoords)) doubleRefAtIndex:resultCoordPos++]) = [((PythagorasDIntersectPoint *) nil_chk(nextPoint)) x];
    (*[((IOSDoubleArray *) nil_chk(resultCoords)) doubleRefAtIndex:resultCoordPos++]) = [((PythagorasDIntersectPoint *) nil_chk(nextPoint)) y];
    (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos++]) = PythagorasDPathIterator_SEG_CLOSE;
  }
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos - 1]) = resultCoordPos;
  coords_ = resultCoords;
  rules_ = resultRules;
  offsets_ = resultOffsets;
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (void)intersectPolygonWithPythagorasDArea:(PythagorasDArea *)area {
  PythagorasDCrossingHelper *crossHelper = [[PythagorasDCrossingHelper alloc] initWithDoubleArray2:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasDArea *) nil_chk(area)).coords } count:2 type:[IOSDoubleArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasDArea *) nil_chk(area)).coordsSize } count:2]];
  IOSObjectArray *intersectPoints = [((PythagorasDCrossingHelper *) nil_chk(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) nil_chk(intersectPoints)) count] == 0) {
    if ([self containsWithPythagorasDIRectangle:[((PythagorasDArea *) nil_chk(area)) bounds]]) {
      [self copy__WithPythagorasDArea:area withPythagorasDArea:self];
    }
    else if (![((PythagorasDArea *) nil_chk(area)) containsWithPythagorasDIRectangle:[self bounds]]) {
      [self reset];
    }
    return;
  }
  IOSDoubleArray *resultCoords = [IOSDoubleArray arrayWithLength:coordsSize_ + ((PythagorasDArea *) nil_chk(area)).coordsSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultRules = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasDArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultOffsets = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasDArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasDIntersectPoint *point = [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0];
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_MOVETO;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
  do {
    (*[((IOSDoubleArray *) nil_chk(resultCoords)) doubleRefAtIndex:resultCoordPos++]) = [((PythagorasDIntersectPoint *) nil_chk(point)) x];
    (*[((IOSDoubleArray *) nil_chk(resultCoords)) doubleRefAtIndex:resultCoordPos++]) = [((PythagorasDIntersectPoint *) nil_chk(point)) y];
    (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_LINETO;
    (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos - 2;
    int curIndex = [((PythagorasDIntersectPoint *) nil_chk(point)) endIndexWithBOOL:YES];
    if ((curIndex < 0) || ([((PythagorasDArea *) nil_chk(area)) containsExactWithDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex] withDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex + 1]] == 0)) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasDArea *) nil_chk(area)) containsExactWithDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex] withDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = YES;
    }
    else {
      isCurrentArea = NO;
    }
    PythagorasDIntersectPoint *nextPoint = [self nextIntersectPointWithPythagorasDIntersectPointArray:intersectPoints withPythagorasDIntersectPoint:point withBOOL:isCurrentArea];
    IOSDoubleArray *coords = (isCurrentArea) ? self.coords : ((PythagorasDArea *) nil_chk(area)).coords;
    int offset = 2 * [((PythagorasDIntersectPoint *) nil_chk(point)) endIndexWithBOOL:isCurrentArea];
    if ((offset >= 0) && ([((PythagorasDIntersectPoint *) nil_chk(nextPoint)) begIndexWithBOOL:isCurrentArea] < [((PythagorasDIntersectPoint *) nil_chk(point)) endIndexWithBOOL:isCurrentArea])) {
      int coordSize = (isCurrentArea) ? self.coordsSize : ((PythagorasDArea *) nil_chk(area)).coordsSize;
      int length = coordSize - offset;
      [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      for (int i = 0; i < length / 2; i++) {
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_LINETO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
        resultCoordPos += 2;
      }
      offset = 0;
    }
    if (offset >= 0) {
      int length = 2 * [((PythagorasDIntersectPoint *) nil_chk(nextPoint)) begIndexWithBOOL:isCurrentArea] - offset + 2;
      [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      for (int i = 0; i < length / 2; i++) {
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_LINETO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
        resultCoordPos += 2;
      }
    }
    point = nextPoint;
  }
  while (point != [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0]);
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos - 1]) = PythagorasDPathIterator_SEG_CLOSE;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos - 1]) = resultCoordPos;
  coords_ = resultCoords;
  rules_ = resultRules;
  offsets_ = resultOffsets;
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (void)subtractCurvePolygonWithPythagorasDArea:(PythagorasDArea *)area {
  PythagorasDCurveCrossingHelper *crossHelper = [[PythagorasDCurveCrossingHelper alloc] initWithDoubleArray2:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasDArea *) nil_chk(area)).coords } count:2 type:[IOSDoubleArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasDArea *) nil_chk(area)).coordsSize } count:2] withIntArray2:[IOSObjectArray arrayWithObjects:(id[]){ rules_, ((PythagorasDArea *) nil_chk(area)).rules } count:2 type:[IOSIntArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ rulesSize_, ((PythagorasDArea *) nil_chk(area)).rulesSize } count:2] withIntArray2:[IOSObjectArray arrayWithObjects:(id[]){ offsets_, ((PythagorasDArea *) nil_chk(area)).offsets } count:2 type:[IOSIntArray iosClass]]];
  IOSObjectArray *intersectPoints = [((PythagorasDCurveCrossingHelper *) nil_chk(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) nil_chk(intersectPoints)) count] == 0 && [self containsWithPythagorasDIRectangle:[((PythagorasDArea *) nil_chk(area)) bounds]]) {
    [self copy__WithPythagorasDArea:area withPythagorasDArea:self];
    return;
  }
  IOSDoubleArray *resultCoords = [IOSDoubleArray arrayWithLength:coordsSize_ + ((PythagorasDArea *) nil_chk(area)).coordsSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultRules = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasDArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultOffsets = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasDArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasDIntersectPoint *point = [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0];
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_MOVETO;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
  do {
    (*[((IOSDoubleArray *) nil_chk(resultCoords)) doubleRefAtIndex:resultCoordPos++]) = [((PythagorasDIntersectPoint *) nil_chk(point)) x];
    (*[((IOSDoubleArray *) nil_chk(resultCoords)) doubleRefAtIndex:resultCoordPos++]) = [((PythagorasDIntersectPoint *) nil_chk(point)) y];
    int curIndex = [((IOSIntArray *) nil_chk(offsets_)) intAtIndex:[((PythagorasDIntersectPoint *) nil_chk(point)) ruleIndexWithBOOL:YES]] % coordsSize_;
    if ([((PythagorasDArea *) nil_chk(area)) containsExactWithDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:curIndex] withDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:curIndex + 1]] == 0) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasDArea *) nil_chk(area)) containsExactWithDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:curIndex] withDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:curIndex + 1]] > 0) {
      isCurrentArea = NO;
    }
    else {
      isCurrentArea = YES;
    }
    PythagorasDIntersectPoint *nextPoint = (isCurrentArea) ? [self nextIntersectPointWithPythagorasDIntersectPointArray:intersectPoints withPythagorasDIntersectPoint:point withBOOL:isCurrentArea] : [self prevIntersectPointWithPythagorasDIntersectPointArray:intersectPoints withPythagorasDIntersectPoint:point withBOOL:isCurrentArea];
    IOSDoubleArray *coords = (isCurrentArea) ? self.coords : ((PythagorasDArea *) nil_chk(area)).coords;
    IOSIntArray *offsets = (isCurrentArea) ? self.offsets : ((PythagorasDArea *) nil_chk(area)).offsets;
    IOSIntArray *rules = (isCurrentArea) ? self.rules : ((PythagorasDArea *) nil_chk(area)).rules;
    int offset = (isCurrentArea) ? [((PythagorasDIntersectPoint *) nil_chk(point)) ruleIndexWithBOOL:isCurrentArea] : [((PythagorasDIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea];
    BOOL isCopyUntilZero = NO;
    if (((isCurrentArea) && ([((PythagorasDIntersectPoint *) nil_chk(point)) ruleIndexWithBOOL:isCurrentArea] > [((PythagorasDIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea])) || ((!isCurrentArea) && ([((PythagorasDIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea] > [((PythagorasDIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea]))) {
      int rulesSize = (isCurrentArea) ? self.rulesSize : ((PythagorasDArea *) nil_chk(area)).rulesSize;
      resultCoordPos = [self includeCoordsAndRulesWithInt:offset + 1 withInt:rulesSize withIntArray:rules withIntArray:offsets withIntArray:resultRules withIntArray:resultOffsets withDoubleArray:resultCoords withDoubleArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasDIntersectPoint:point withBOOL:isCurrentArea withBOOL:NO withInt:2];
      resultRulesPos += rulesSize - offset - 1;
      offset = 1;
      isCopyUntilZero = YES;
    }
    int length = [((PythagorasDIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea] - offset + 1;
    if (isCopyUntilZero) {
      offset = 0;
      isCopyUntilZero = NO;
    }
    resultCoordPos = [self includeCoordsAndRulesWithInt:offset withInt:length withIntArray:rules withIntArray:offsets withIntArray:resultRules withIntArray:resultOffsets withDoubleArray:resultCoords withDoubleArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasDIntersectPoint:point withBOOL:isCurrentArea withBOOL:YES withInt:2];
    if ((length == offset) && (([((IOSIntArray *) nil_chk(rules)) intAtIndex:offset] == PythagorasDPathIterator_SEG_QUADTO) || ([((IOSIntArray *) nil_chk(rules)) intAtIndex:offset] == PythagorasDPathIterator_SEG_CUBICTO))) {
      resultRulesPos++;
    }
    else {
      resultRulesPos = (length < offset || isCopyUntilZero) ? resultRulesPos + 1 : resultRulesPos + length - offset;
    }
    point = nextPoint;
  }
  while (point != [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0]);
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos++]) = PythagorasDPathIterator_SEG_CLOSE;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos - 1]) = resultCoordPos;
  coords_ = resultCoords;
  rules_ = resultRules;
  offsets_ = resultOffsets;
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (void)subtractPolygonWithPythagorasDArea:(PythagorasDArea *)area {
  PythagorasDCrossingHelper *crossHelper = [[PythagorasDCrossingHelper alloc] initWithDoubleArray2:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasDArea *) nil_chk(area)).coords } count:2 type:[IOSDoubleArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasDArea *) nil_chk(area)).coordsSize } count:2]];
  IOSObjectArray *intersectPoints = [((PythagorasDCrossingHelper *) nil_chk(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) nil_chk(intersectPoints)) count] == 0) {
    if ([self containsWithPythagorasDIRectangle:[((PythagorasDArea *) nil_chk(area)) bounds]]) {
      [self copy__WithPythagorasDArea:area withPythagorasDArea:self];
      return;
    }
    return;
  }
  IOSDoubleArray *resultCoords = [IOSDoubleArray arrayWithLength:2 * (coordsSize_ + ((PythagorasDArea *) nil_chk(area)).coordsSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count])];
  IOSIntArray *resultRules = [IOSIntArray arrayWithLength:2 * (rulesSize_ + ((PythagorasDArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count])];
  IOSIntArray *resultOffsets = [IOSIntArray arrayWithLength:2 * (rulesSize_ + ((PythagorasDArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count])];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  int countPoints = 0;
  BOOL curArea = NO;
  BOOL addArea = NO;
  PythagorasDIntersectPoint *point = [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0];
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_MOVETO;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
  do {
    (*[((IOSDoubleArray *) nil_chk(resultCoords)) doubleRefAtIndex:resultCoordPos++]) = [((PythagorasDIntersectPoint *) nil_chk(point)) x];
    (*[((IOSDoubleArray *) nil_chk(resultCoords)) doubleRefAtIndex:resultCoordPos++]) = [((PythagorasDIntersectPoint *) nil_chk(point)) y];
    (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_LINETO;
    (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos - 2;
    int curIndex = [((PythagorasDIntersectPoint *) nil_chk(point)) endIndexWithBOOL:YES];
    if ((curIndex < 0) || ([((PythagorasDArea *) nil_chk(area)) isVertexWithDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex] withDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex + 1]] && [((PythagorasDCrossingHelper *) nil_chk(crossHelper)) containsPointWithDoubleArray:[IOSDoubleArray arrayWithDoubles:(double[]){ [((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex], [((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex + 1] } count:2]] && ([((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex] != [((PythagorasDIntersectPoint *) nil_chk(point)) x] || [((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex + 1] != [((PythagorasDIntersectPoint *) nil_chk(point)) y]))) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasDArea *) nil_chk(area)) containsExactWithDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex] withDouble:[((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = NO;
    }
    else {
      isCurrentArea = YES;
    }
    if (countPoints >= (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]) {
      isCurrentArea = !isCurrentArea;
    }
    if (isCurrentArea) {
      curArea = YES;
    }
    else {
      addArea = YES;
    }
    PythagorasDIntersectPoint *nextPoint = (isCurrentArea) ? [self nextIntersectPointWithPythagorasDIntersectPointArray:intersectPoints withPythagorasDIntersectPoint:point withBOOL:isCurrentArea] : [self prevIntersectPointWithPythagorasDIntersectPointArray:intersectPoints withPythagorasDIntersectPoint:point withBOOL:isCurrentArea];
    IOSDoubleArray *coords = (isCurrentArea) ? self.coords : ((PythagorasDArea *) nil_chk(area)).coords;
    int offset = (isCurrentArea) ? 2 * [((PythagorasDIntersectPoint *) nil_chk(point)) endIndexWithBOOL:isCurrentArea] : 2 * [((PythagorasDIntersectPoint *) nil_chk(nextPoint)) endIndexWithBOOL:isCurrentArea];
    if ((offset > 0) && (((isCurrentArea) && ([((PythagorasDIntersectPoint *) nil_chk(nextPoint)) begIndexWithBOOL:isCurrentArea] < [((PythagorasDIntersectPoint *) nil_chk(point)) endIndexWithBOOL:isCurrentArea])) || ((!isCurrentArea) && ([((PythagorasDIntersectPoint *) nil_chk(nextPoint)) endIndexWithBOOL:isCurrentArea] < [((PythagorasDIntersectPoint *) nil_chk(nextPoint)) begIndexWithBOOL:isCurrentArea])))) {
      int coordSize = (isCurrentArea) ? self.coordsSize : ((PythagorasDArea *) nil_chk(area)).coordsSize;
      int length = coordSize - offset;
      if (isCurrentArea) {
        [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      }
      else {
        IOSDoubleArray *temp = [IOSDoubleArray arrayWithLength:length];
        [JavaLangSystem arraycopyWithId:coords withInt:offset withId:temp withInt:0 withInt:length];
        [self reverseCopyWithDoubleArray:temp];
        [JavaLangSystem arraycopyWithId:temp withInt:0 withId:resultCoords withInt:resultCoordPos withInt:length];
      }
      for (int i = 0; i < length / 2; i++) {
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_LINETO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
        resultCoordPos += 2;
      }
      offset = 0;
    }
    if (offset >= 0) {
      int length = (isCurrentArea) ? 2 * [((PythagorasDIntersectPoint *) nil_chk(nextPoint)) begIndexWithBOOL:isCurrentArea] - offset + 2 : 2 * [((PythagorasDIntersectPoint *) nil_chk(point)) begIndexWithBOOL:isCurrentArea] - offset + 2;
      if (isCurrentArea) {
        [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      }
      else {
        IOSDoubleArray *temp = [IOSDoubleArray arrayWithLength:length];
        [JavaLangSystem arraycopyWithId:coords withInt:offset withId:temp withInt:0 withInt:length];
        [self reverseCopyWithDoubleArray:temp];
        [JavaLangSystem arraycopyWithId:temp withInt:0 withId:resultCoords withInt:resultCoordPos withInt:length];
      }
      for (int i = 0; i < length / 2; i++) {
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_LINETO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
        resultCoordPos += 2;
      }
    }
    point = nextPoint;
    countPoints++;
  }
  while (point != [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0] || !(curArea && addArea));
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos - 1]) = PythagorasDPathIterator_SEG_CLOSE;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos - 1]) = resultCoordPos;
  coords_ = resultCoords;
  rules_ = resultRules;
  offsets_ = resultOffsets;
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (PythagorasDIntersectPoint *)nextIntersectPointWithPythagorasDIntersectPointArray:(IOSObjectArray *)iPoints
                                                      withPythagorasDIntersectPoint:(PythagorasDIntersectPoint *)isectPoint
                                                                           withBOOL:(BOOL)isCurrentArea {
  int endIndex = [((PythagorasDIntersectPoint *) nil_chk(isectPoint)) endIndexWithBOOL:isCurrentArea];
  if (endIndex < 0) {
    return [((IOSObjectArray *) nil_chk(iPoints)) objectAtIndex:[JavaLangMath absWithInt:endIndex] - 1];
  }
  PythagorasDIntersectPoint *firstIsectPoint = nil;
  PythagorasDIntersectPoint *nextIsectPoint = nil;
  {
    IOSObjectArray *a__ = iPoints;
    int n__ = (int) [((IOSObjectArray *) nil_chk(a__)) count];
    for (int i__ = 0; i__ < n__; i__++) {
      PythagorasDIntersectPoint *point = [((IOSObjectArray *) nil_chk(a__)) objectAtIndex:i__];
      int begIndex = [((PythagorasDIntersectPoint *) nil_chk(point)) begIndexWithBOOL:isCurrentArea];
      if (begIndex >= 0) {
        if (firstIsectPoint == nil) {
          firstIsectPoint = point;
        }
        else if (begIndex < [firstIsectPoint begIndexWithBOOL:isCurrentArea]) {
          firstIsectPoint = point;
        }
      }
      if (endIndex <= begIndex) {
        if (nextIsectPoint == nil) {
          nextIsectPoint = point;
        }
        else if (begIndex < [nextIsectPoint begIndexWithBOOL:isCurrentArea]) {
          nextIsectPoint = point;
        }
      }
    }
  }
  return (nextIsectPoint != nil) ? nextIsectPoint : firstIsectPoint;
}

- (PythagorasDIntersectPoint *)prevIntersectPointWithPythagorasDIntersectPointArray:(IOSObjectArray *)iPoints
                                                      withPythagorasDIntersectPoint:(PythagorasDIntersectPoint *)isectPoint
                                                                           withBOOL:(BOOL)isCurrentArea {
  int begIndex = [((PythagorasDIntersectPoint *) nil_chk(isectPoint)) begIndexWithBOOL:isCurrentArea];
  if (begIndex < 0) {
    return [((IOSObjectArray *) nil_chk(iPoints)) objectAtIndex:[JavaLangMath absWithInt:begIndex] - 1];
  }
  PythagorasDIntersectPoint *firstIsectPoint = nil;
  PythagorasDIntersectPoint *predIsectPoint = nil;
  {
    IOSObjectArray *a__ = iPoints;
    int n__ = (int) [((IOSObjectArray *) nil_chk(a__)) count];
    for (int i__ = 0; i__ < n__; i__++) {
      PythagorasDIntersectPoint *point = [((IOSObjectArray *) nil_chk(a__)) objectAtIndex:i__];
      int endIndex = [((PythagorasDIntersectPoint *) nil_chk(point)) endIndexWithBOOL:isCurrentArea];
      if (endIndex >= 0) {
        if (firstIsectPoint == nil) {
          firstIsectPoint = point;
        }
        else if (endIndex < [firstIsectPoint endIndexWithBOOL:isCurrentArea]) {
          firstIsectPoint = point;
        }
      }
      if (endIndex <= begIndex) {
        if (predIsectPoint == nil) {
          predIsectPoint = point;
        }
        else if (endIndex > [predIsectPoint endIndexWithBOOL:isCurrentArea]) {
          predIsectPoint = point;
        }
      }
    }
  }
  return (predIsectPoint != nil) ? predIsectPoint : firstIsectPoint;
}

- (int)includeCoordsAndRulesWithInt:(int)offset
                            withInt:(int)length
                       withIntArray:(IOSIntArray *)rules
                       withIntArray:(IOSIntArray *)offsets
                       withIntArray:(IOSIntArray *)resultRules
                       withIntArray:(IOSIntArray *)resultOffsets
                    withDoubleArray:(IOSDoubleArray *)resultCoords
                    withDoubleArray:(IOSDoubleArray *)coords
                            withInt:(int)resultRulesPos
                            withInt:(int)resultCoordPos
      withPythagorasDIntersectPoint:(PythagorasDIntersectPoint *)point
                           withBOOL:(BOOL)isCurrentArea
                           withBOOL:(BOOL)way
                            withInt:(int)operation {
  IOSDoubleArray *temp = [IOSDoubleArray arrayWithLength:8 * length];
  int coordsCount = 0;
  BOOL isMoveIndex = YES;
  BOOL isMoveLength = YES;
  BOOL additional = NO;
  if (length <= offset) {
    for (int i = resultRulesPos; i < resultRulesPos + 1; i++) {
      (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:i]) = PythagorasDPathIterator_SEG_LINETO;
    }
  }
  else {
    int j = resultRulesPos;
    for (int i = offset; i < length; i++) {
      (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:j++]) = PythagorasDPathIterator_SEG_LINETO;
    }
  }
  if ((length == offset) && (([((IOSIntArray *) nil_chk(rules)) intAtIndex:offset] == PythagorasDPathIterator_SEG_QUADTO) || ([((IOSIntArray *) nil_chk(rules)) intAtIndex:offset] == PythagorasDPathIterator_SEG_CUBICTO))) {
    length++;
    additional = YES;
  }
  for (int i = offset; i < length; i++) {
    int index = [((IOSIntArray *) nil_chk(offsets)) intAtIndex:i];
    if (!isMoveIndex) {
      index -= 2;
    }
    if (!isMoveLength) {
      length++;
      isMoveLength = YES;
    }
    {
      BOOL isLeft;
      IOSDoubleArray *coefs;
      switch ([((IOSIntArray *) nil_chk(rules)) intAtIndex:i]) {
        case PythagorasDPathIterator_SEG_MOVETO:
        isMoveIndex = NO;
        isMoveLength = NO;
        break;
        case PythagorasDPathIterator_SEG_LINETO:
        case PythagorasDPathIterator_SEG_CLOSE:
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_LINETO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos + 2;
        isLeft = [PythagorasDCrossingHelper compareWithDouble:[((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index] withDouble:[((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index + 1] withDouble:[((PythagorasDIntersectPoint *) nil_chk(point)) x] withDouble:[((PythagorasDIntersectPoint *) nil_chk(point)) y]] > 0;
        if (way || !isLeft) {
          (*[((IOSDoubleArray *) nil_chk(temp)) doubleRefAtIndex:coordsCount++]) = [((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index];
          (*[((IOSDoubleArray *) nil_chk(temp)) doubleRefAtIndex:coordsCount++]) = [((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index + 1];
        }
        break;
        case PythagorasDPathIterator_SEG_QUADTO:
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_QUADTO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos + 4;
        coefs = [IOSDoubleArray arrayWithDoubles:(double[]){ [((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index - 2], [((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index - 1], [((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index], [((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index + 1], [((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index + 2], [((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index + 3] } count:6];
        isLeft = [PythagorasDCrossingHelper compareWithDouble:[((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index - 2] withDouble:[((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index - 1] withDouble:[((PythagorasDIntersectPoint *) nil_chk(point)) x] withDouble:[((PythagorasDIntersectPoint *) nil_chk(point)) y]] > 0;
        if ((!additional) && (operation == 0 || operation == 2)) {
          isLeft = !isLeft;
          way = NO;
        }
        [PythagorasDGeometryUtil subQuadWithDoubleArray:coefs withDouble:[((PythagorasDIntersectPoint *) nil_chk(point)) paramWithBOOL:isCurrentArea] withBOOL:isLeft];
        if (way || isLeft) {
          (*[((IOSDoubleArray *) nil_chk(temp)) doubleRefAtIndex:coordsCount++]) = [((IOSDoubleArray *) nil_chk(coefs)) doubleAtIndex:2];
          (*[((IOSDoubleArray *) nil_chk(temp)) doubleRefAtIndex:coordsCount++]) = [((IOSDoubleArray *) nil_chk(coefs)) doubleAtIndex:3];
        }
        else {
          [JavaLangSystem arraycopyWithId:coefs withInt:2 withId:temp withInt:coordsCount withInt:4];
          coordsCount += 4;
        }
        break;
        case PythagorasDPathIterator_SEG_CUBICTO:
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasDPathIterator_SEG_CUBICTO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos + 6;
        coefs = [IOSDoubleArray arrayWithDoubles:(double[]){ [((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index - 2], [((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index - 1], [((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index], [((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index + 1], [((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index + 2], [((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index + 3], [((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index + 4], [((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index + 5] } count:8];
        isLeft = [PythagorasDCrossingHelper compareWithDouble:[((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index - 2] withDouble:[((IOSDoubleArray *) nil_chk(coords)) doubleAtIndex:index - 1] withDouble:[((PythagorasDIntersectPoint *) nil_chk(point)) x] withDouble:[((PythagorasDIntersectPoint *) nil_chk(point)) y]] > 0;
        [PythagorasDGeometryUtil subCubicWithDoubleArray:coefs withDouble:[((PythagorasDIntersectPoint *) nil_chk(point)) paramWithBOOL:isCurrentArea] withBOOL:!isLeft];
        if (isLeft) {
          [JavaLangSystem arraycopyWithId:coefs withInt:2 withId:temp withInt:coordsCount withInt:6];
          coordsCount += 6;
        }
        else {
          [JavaLangSystem arraycopyWithId:coefs withInt:2 withId:temp withInt:coordsCount withInt:4];
          coordsCount += 4;
        }
        break;
      }
    }
  }
  if (operation == 2 && !isCurrentArea && coordsCount > 2) {
    [self reverseCopyWithDoubleArray:temp];
    [JavaLangSystem arraycopyWithId:temp withInt:0 withId:resultCoords withInt:resultCoordPos withInt:coordsCount];
  }
  else {
    [JavaLangSystem arraycopyWithId:temp withInt:0 withId:resultCoords withInt:resultCoordPos withInt:coordsCount];
  }
  return (resultCoordPos + coordsCount);
}

- (void)copy__WithPythagorasDArea:(PythagorasDArea *)src
              withPythagorasDArea:(PythagorasDArea *)dst OBJC_METHOD_FAMILY_NONE {
  ((PythagorasDArea *) nil_chk(dst)).coordsSize = ((PythagorasDArea *) nil_chk(src)).coordsSize;
  ((PythagorasDArea *) nil_chk(dst)).coords = [PythagorasUtilPlatform cloneWithDoubleArray:((PythagorasDArea *) nil_chk(src)).coords];
  ((PythagorasDArea *) nil_chk(dst)).rulesSize = ((PythagorasDArea *) nil_chk(src)).rulesSize;
  ((PythagorasDArea *) nil_chk(dst)).rules = [PythagorasUtilPlatform cloneWithIntArray:((PythagorasDArea *) nil_chk(src)).rules];
  ((PythagorasDArea *) nil_chk(dst)).moveToCount = ((PythagorasDArea *) nil_chk(src)).moveToCount;
  ((PythagorasDArea *) nil_chk(dst)).offsets = [PythagorasUtilPlatform cloneWithIntArray:((PythagorasDArea *) nil_chk(src)).offsets];
}

- (int)containsExactWithDouble:(double)x
                    withDouble:(double)y {
  id<PythagorasDPathIterator> pi = [self pathIteratorWithPythagorasDTransform:nil];
  int crossCount = [PythagorasDCrossing crossPathWithPythagorasDPathIterator:pi withDouble:x withDouble:y];
  if ([PythagorasDCrossing isInsideEvenOddWithInt:crossCount]) {
    return 1;
  }
  IOSDoubleArray *segmentCoords = [IOSDoubleArray arrayWithLength:6];
  IOSDoubleArray *resultPoints = [IOSDoubleArray arrayWithLength:6];
  int rule;
  double curX = -1;
  double curY = -1;
  double moveX = -1;
  double moveY = -1;
  for (pi = [self pathIteratorWithPythagorasDTransform:nil]; ![((id<PythagorasDPathIterator>) nil_chk(pi)) isDone]; [((id<PythagorasDPathIterator>) nil_chk(pi)) next]) {
    rule = [((id<PythagorasDPathIterator>) nil_chk(pi)) currentSegmentWithDoubleArray:segmentCoords];
    switch (rule) {
      case PythagorasDPathIterator_SEG_MOVETO:
      moveX = curX = [((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:0];
      moveY = curY = [((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:1];
      break;
      case PythagorasDPathIterator_SEG_LINETO:
      if ([PythagorasDGeometryUtil intersectLinesWithDouble:curX withDouble:curY withDouble:[((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:1] withDouble:x withDouble:y withDouble:x withDouble:y withDoubleArray:resultPoints] != 0) {
        return 0;
      }
      curX = [((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:0];
      curY = [((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:1];
      break;
      case PythagorasDPathIterator_SEG_QUADTO:
      if ([PythagorasDGeometryUtil intersectLineAndQuadWithDouble:x withDouble:y withDouble:x withDouble:y withDouble:curX withDouble:curY withDouble:[((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:3] withDoubleArray:resultPoints] > 0) {
        return 0;
      }
      curX = [((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:2];
      curY = [((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:3];
      break;
      case PythagorasDPathIterator_SEG_CUBICTO:
      if ([PythagorasDGeometryUtil intersectLineAndCubicWithDouble:x withDouble:y withDouble:x withDouble:y withDouble:curX withDouble:curY withDouble:[((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:4] withDouble:[((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:5] withDoubleArray:resultPoints] > 0) {
        return 0;
      }
      curX = [((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:4];
      curY = [((IOSDoubleArray *) nil_chk(segmentCoords)) doubleAtIndex:5];
      break;
      case PythagorasDPathIterator_SEG_CLOSE:
      if ([PythagorasDGeometryUtil intersectLinesWithDouble:curX withDouble:curY withDouble:moveX withDouble:moveY withDouble:x withDouble:y withDouble:x withDouble:y withDoubleArray:resultPoints] != 0) {
        return 0;
      }
      curX = moveX;
      curY = moveY;
      break;
    }
  }
  return -1;
}

- (void)reverseCopyWithDoubleArray:(IOSDoubleArray *)coords {
  IOSDoubleArray *temp = [IOSDoubleArray arrayWithLength:(int) [((IOSDoubleArray *) nil_chk(coords)) count]];
  [JavaLangSystem arraycopyWithId:coords withInt:0 withId:temp withInt:0 withInt:(int) [((IOSDoubleArray *) nil_chk(coords)) count]];
  for (int i = 0; i < (int) [((IOSDoubleArray *) nil_chk(coords)) count]; ) {
    (*[((IOSDoubleArray *) nil_chk(coords)) doubleRefAtIndex:i]) = [((IOSDoubleArray *) nil_chk(temp)) doubleAtIndex:(int) [((IOSDoubleArray *) nil_chk(coords)) count] - i - 2];
    (*[((IOSDoubleArray *) nil_chk(coords)) doubleRefAtIndex:i + 1]) = [((IOSDoubleArray *) nil_chk(temp)) doubleAtIndex:(int) [((IOSDoubleArray *) nil_chk(coords)) count] - i - 1];
    i = i + 2;
  }
}

- (double)areaBoundsSquare {
  PythagorasDRectangle *bounds = [self bounds];
  return [((PythagorasDRectangle *) nil_chk(bounds)) height] * [((PythagorasDRectangle *) nil_chk(bounds)) width];
}

- (BOOL)isVertexWithDouble:(double)x
                withDouble:(double)y {
  for (int i = 0; i < coordsSize_; ) {
    if (x == [((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:i++] && y == [((IOSDoubleArray *) nil_chk(coords_)) doubleAtIndex:i++]) {
      return YES;
    }
  }
  return NO;
}

+ (IOSDoubleArray *)adjustSizeWithDoubleArray:(IOSDoubleArray *)array
                                      withInt:(int)newSize {
  if (newSize <= (int) [((IOSDoubleArray *) nil_chk(array)) count]) {
    return array;
  }
  IOSDoubleArray *newArray = [IOSDoubleArray arrayWithLength:2 * newSize];
  [JavaLangSystem arraycopyWithId:array withInt:0 withId:newArray withInt:0 withInt:(int) [((IOSDoubleArray *) nil_chk(array)) count]];
  return newArray;
}

+ (IOSIntArray *)adjustSizeWithIntArray:(IOSIntArray *)array
                                withInt:(int)newSize {
  if (newSize <= (int) [((IOSIntArray *) nil_chk(array)) count]) {
    return array;
  }
  IOSIntArray *newArray = [IOSIntArray arrayWithLength:2 * newSize];
  [JavaLangSystem arraycopyWithId:array withInt:0 withId:newArray withInt:0 withInt:(int) [((IOSIntArray *) nil_chk(array)) count]];
  return newArray;
}

- (id)copyWithZone:(NSZone *)zone {
  return [self clone];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  PythagorasDArea *typedCopy = (PythagorasDArea *) copy;
  typedCopy.coords = coords_;
  typedCopy.coordsSize = coordsSize_;
  typedCopy.rules = rules_;
  typedCopy.rulesSize = rulesSize_;
  typedCopy.offsets = offsets_;
  typedCopy.moveToCount = moveToCount_;
  typedCopy.isPolygonal_ = isPolygonal__;
}

@end
@implementation PythagorasDArea_AreaPathIterator

@synthesize this$0 = this$0_;
@synthesize transform = transform_;
@synthesize curRuleIndex = curRuleIndex_;
@synthesize curCoordIndex = curCoordIndex_;

- (id)initWithPythagorasDArea:(PythagorasDArea *)outer$
     withPythagorasDTransform:(id<PythagorasDTransform>)t {
  if ((self = [super init])) {
    this$0_ = outer$;
    curRuleIndex_ = 0;
    curCoordIndex_ = 0;
    self.transform = t;
  }
  return self;
}

- (int)windingRule {
  return PythagorasDPathIterator_WIND_EVEN_ODD;
}

- (BOOL)isDone {
  return curRuleIndex_ >= this$0_.rulesSize;
}

- (void)next {
  switch ([((IOSIntArray *) nil_chk(this$0_.rules)) intAtIndex:curRuleIndex_]) {
    case PythagorasDPathIterator_SEG_MOVETO:
    case PythagorasDPathIterator_SEG_LINETO:
    curCoordIndex_ += 2;
    break;
    case PythagorasDPathIterator_SEG_QUADTO:
    curCoordIndex_ += 4;
    break;
    case PythagorasDPathIterator_SEG_CUBICTO:
    curCoordIndex_ += 6;
    break;
  }
  curRuleIndex_++;
}

- (int)currentSegmentWithDoubleArray:(IOSDoubleArray *)c {
  if ([self isDone]) {
    @throw [[JavaUtilNoSuchElementException alloc] initWithNSString:@"Iterator out of bounds"];
  }
  int count = 0;
  switch ([((IOSIntArray *) nil_chk(this$0_.rules)) intAtIndex:curRuleIndex_]) {
    case PythagorasDPathIterator_SEG_CUBICTO:
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:4]) = [((IOSDoubleArray *) nil_chk(this$0_.coords)) doubleAtIndex:curCoordIndex_ + 4];
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:5]) = [((IOSDoubleArray *) nil_chk(this$0_.coords)) doubleAtIndex:curCoordIndex_ + 5];
    count = 1;
    case PythagorasDPathIterator_SEG_QUADTO:
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:2]) = [((IOSDoubleArray *) nil_chk(this$0_.coords)) doubleAtIndex:curCoordIndex_ + 2];
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:3]) = [((IOSDoubleArray *) nil_chk(this$0_.coords)) doubleAtIndex:curCoordIndex_ + 3];
    count += 1;
    case PythagorasDPathIterator_SEG_MOVETO:
    case PythagorasDPathIterator_SEG_LINETO:
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:0]) = [((IOSDoubleArray *) nil_chk(this$0_.coords)) doubleAtIndex:curCoordIndex_];
    (*[((IOSDoubleArray *) nil_chk(c)) doubleRefAtIndex:1]) = [((IOSDoubleArray *) nil_chk(this$0_.coords)) doubleAtIndex:curCoordIndex_ + 1];
    count += 1;
  }
  if (transform_ != nil) {
    [transform_ transformWithDoubleArray:c withInt:0 withDoubleArray:c withInt:0 withInt:count];
  }
  return [((IOSIntArray *) nil_chk(this$0_.rules)) intAtIndex:curRuleIndex_];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  PythagorasDArea_AreaPathIterator *typedCopy = (PythagorasDArea_AreaPathIterator *) copy;
  typedCopy.this$0 = this$0_;
  typedCopy.transform = transform_;
  typedCopy.curRuleIndex = curRuleIndex_;
  typedCopy.curCoordIndex = curCoordIndex_;
}

@end
