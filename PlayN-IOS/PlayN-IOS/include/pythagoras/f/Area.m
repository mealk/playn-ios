//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: pythagoras/f/Area.java
//
//  Created by Thomas on 7/25/13.
//

#include "IOSClass.h"
#include "IOSFloatArray.h"
#include "IOSIntArray.h"
#include "IOSObjectArray.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"
#include "java/util/NoSuchElementException.h"
#include "pythagoras/f/Area.h"
#include "pythagoras/f/Crossing.h"
#include "pythagoras/f/CrossingHelper.h"
#include "pythagoras/f/CurveCrossingHelper.h"
#include "pythagoras/f/FlatteningPathIterator.h"
#include "pythagoras/f/GeometryUtil.h"
#include "pythagoras/f/IPoint.h"
#include "pythagoras/f/IRectangle.h"
#include "pythagoras/f/IShape.h"
#include "pythagoras/f/IntersectPoint.h"
#include "pythagoras/f/PathIterator.h"
#include "pythagoras/f/Rectangle.h"
#include "pythagoras/f/Transform.h"
#include "pythagoras/f/Transforms.h"
#include "pythagoras/util/Platform.h"

@implementation PythagorasFArea

@synthesize coords = coords_;
@synthesize coordsSize = coordsSize_;
@synthesize rules = rules_;
@synthesize rulesSize = rulesSize_;
@synthesize offsets = offsets_;
@synthesize moveToCount = moveToCount_;
@synthesize isPolygonal_ = isPolygonal__;

- (id)init {
  if ((self = [super init])) {
    coords_ = [IOSFloatArray arrayWithLength:20];
    coordsSize_ = 0;
    rules_ = [IOSIntArray arrayWithLength:10];
    rulesSize_ = 0;
    offsets_ = [IOSIntArray arrayWithLength:10];
    moveToCount_ = 0;
    isPolygonal__ = YES;
  }
  return self;
}

- (id)initWithPythagorasFIShape:(id<PythagorasFIShape>)s {
  if ((self = [super init])) {
    coords_ = [IOSFloatArray arrayWithLength:20];
    coordsSize_ = 0;
    rules_ = [IOSIntArray arrayWithLength:10];
    rulesSize_ = 0;
    offsets_ = [IOSIntArray arrayWithLength:10];
    moveToCount_ = 0;
    isPolygonal__ = YES;
    IOSFloatArray *segmentCoords = [IOSFloatArray arrayWithLength:6];
    float lastMoveX = 0.0f;
    float lastMoveY = 0.0f;
    int rulesIndex = 0;
    int coordsIndex = 0;
    for (id<PythagorasFPathIterator> pi = [((id<PythagorasFIShape>) nil_chk(s)) pathIteratorWithPythagorasFTransform:nil]; ![((id<PythagorasFPathIterator>) nil_chk(pi)) isDone]; [((id<PythagorasFPathIterator>) nil_chk(pi)) next]) {
      coords_ = [PythagorasFArea adjustSizeWithFloatArray:coords_ withInt:coordsIndex + 6];
      rules_ = [PythagorasFArea adjustSizeWithIntArray:rules_ withInt:rulesIndex + 1];
      offsets_ = [PythagorasFArea adjustSizeWithIntArray:offsets_ withInt:rulesIndex + 1];
      (*[((IOSIntArray *) nil_chk(rules_)) intRefAtIndex:rulesIndex]) = [((id<PythagorasFPathIterator>) nil_chk(pi)) currentSegmentWithFloatArray:segmentCoords];
      (*[((IOSIntArray *) nil_chk(offsets_)) intRefAtIndex:rulesIndex]) = coordsIndex;
      switch ([((IOSIntArray *) nil_chk(rules_)) intAtIndex:rulesIndex]) {
        case PythagorasFPathIterator_SEG_MOVETO:
        (*[((IOSFloatArray *) nil_chk(coords_)) floatRefAtIndex:coordsIndex++]) = [((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:0];
        (*[((IOSFloatArray *) nil_chk(coords_)) floatRefAtIndex:coordsIndex++]) = [((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:1];
        lastMoveX = [((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:0];
        lastMoveY = [((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:1];
        ++moveToCount_;
        break;
        case PythagorasFPathIterator_SEG_LINETO:
        if (([((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:0] != lastMoveX) || ([((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:1] != lastMoveY)) {
          (*[((IOSFloatArray *) nil_chk(coords_)) floatRefAtIndex:coordsIndex++]) = [((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:0];
          (*[((IOSFloatArray *) nil_chk(coords_)) floatRefAtIndex:coordsIndex++]) = [((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:1];
        }
        else {
          --rulesIndex;
        }
        break;
        case PythagorasFPathIterator_SEG_QUADTO:
        [JavaLangSystem arraycopyWithId:segmentCoords withInt:0 withId:coords_ withInt:coordsIndex withInt:4];
        coordsIndex += 4;
        isPolygonal__ = NO;
        break;
        case PythagorasFPathIterator_SEG_CUBICTO:
        [JavaLangSystem arraycopyWithId:segmentCoords withInt:0 withId:coords_ withInt:coordsIndex withInt:6];
        coordsIndex += 6;
        isPolygonal__ = NO;
        break;
        case PythagorasFPathIterator_SEG_CLOSE:
        break;
      }
      ++rulesIndex;
    }
    if ((rulesIndex != 0) && ([((IOSIntArray *) nil_chk(rules_)) intAtIndex:rulesIndex - 1] != PythagorasFPathIterator_SEG_CLOSE)) {
      (*[((IOSIntArray *) nil_chk(rules_)) intRefAtIndex:rulesIndex]) = PythagorasFPathIterator_SEG_CLOSE;
      (*[((IOSIntArray *) nil_chk(offsets_)) intRefAtIndex:rulesIndex]) = coordsSize_;
    }
    rulesSize_ = rulesIndex;
    coordsSize_ = coordsIndex;
  }
  return self;
}

- (BOOL)isPolygonal {
  return isPolygonal__;
}

- (BOOL)isRectangular {
  return (isPolygonal__) && (rulesSize_ <= 5) && (coordsSize_ <= 8) && ([((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:1] == [((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:3]) && ([((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:7] == [((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:5]) && ([((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:0] == [((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:6]) && ([((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2] == [((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:4]);
}

- (BOOL)isSingular {
  return (moveToCount_ <= 1);
}

- (void)reset {
  coordsSize_ = 0;
  rulesSize_ = 0;
}

- (void)transformWithPythagorasFTransform:(id<PythagorasFTransform>)t {
  [self copy__WithPythagorasFArea:[[PythagorasFArea alloc] initWithPythagorasFIShape:[PythagorasFTransforms createTransformedShapeWithPythagorasFTransform:t withPythagorasFIShape:self]] withPythagorasFArea:self];
}

- (PythagorasFArea *)createTransformedAreaWithPythagorasFTransform:(id<PythagorasFTransform>)t {
  return [[PythagorasFArea alloc] initWithPythagorasFIShape:[PythagorasFTransforms createTransformedShapeWithPythagorasFTransform:t withPythagorasFIShape:self]];
}

- (void)addWithPythagorasFArea:(PythagorasFArea *)area {
  if (area == nil || [((PythagorasFArea *) nil_chk(area)) isEmpty]) {
    return;
  }
  else if ([self isEmpty]) {
    [self copy__WithPythagorasFArea:area withPythagorasFArea:self];
    return;
  }
  if ([self isPolygonal] && [((PythagorasFArea *) nil_chk(area)) isPolygonal]) {
    [self addPolygonWithPythagorasFArea:area];
  }
  else {
    [self addCurvePolygonWithPythagorasFArea:area];
  }
  if ([self areaBoundsSquare] < [PythagorasFGeometryUtil EPSILON]) {
    [self reset];
  }
}

- (void)intersectWithPythagorasFArea:(PythagorasFArea *)area {
  if (area == nil) {
    return;
  }
  else if ([self isEmpty] || [area isEmpty]) {
    [self reset];
    return;
  }
  if ([self isPolygonal] && [((PythagorasFArea *) nil_chk(area)) isPolygonal]) {
    [self intersectPolygonWithPythagorasFArea:area];
  }
  else {
    [self intersectCurvePolygonWithPythagorasFArea:area];
  }
  if ([self areaBoundsSquare] < [PythagorasFGeometryUtil EPSILON]) {
    [self reset];
  }
}

- (void)subtractWithPythagorasFArea:(PythagorasFArea *)area {
  if (area == nil || [self isEmpty] || [((PythagorasFArea *) nil_chk(area)) isEmpty]) {
    return;
  }
  if ([self isPolygonal] && [((PythagorasFArea *) nil_chk(area)) isPolygonal]) {
    [self subtractPolygonWithPythagorasFArea:area];
  }
  else {
    [self subtractCurvePolygonWithPythagorasFArea:area];
  }
  if ([self areaBoundsSquare] < [PythagorasFGeometryUtil EPSILON]) {
    [self reset];
  }
}

- (void)exclusiveOrWithPythagorasFArea:(PythagorasFArea *)area {
  PythagorasFArea *a = [self clone];
  [((PythagorasFArea *) nil_chk(a)) intersectWithPythagorasFArea:area];
  [self addWithPythagorasFArea:area];
  [self subtractWithPythagorasFArea:a];
}

- (BOOL)isEmpty {
  return (rulesSize_ == 0) && (coordsSize_ == 0);
}

- (BOOL)containsWithFloat:(float)x
                withFloat:(float)y {
  return ![self isEmpty] && [self containsExactWithFloat:x withFloat:y] > 0;
}

- (BOOL)containsWithFloat:(float)x
                withFloat:(float)y
                withFloat:(float)width
                withFloat:(float)height {
  int crossCount = [PythagorasFCrossing intersectPathWithPythagorasFPathIterator:[self pathIteratorWithPythagorasFTransform:nil] withFloat:x withFloat:y withFloat:width withFloat:height];
  return crossCount != PythagorasFCrossing_CROSSING && [PythagorasFCrossing isInsideEvenOddWithInt:crossCount];
}

- (BOOL)containsWithPythagorasFIPoint:(id<PythagorasFIPoint>)p {
  return [self containsWithFloat:[((id<PythagorasFIPoint>) nil_chk(p)) x] withFloat:[((id<PythagorasFIPoint>) nil_chk(p)) y]];
}

- (BOOL)containsWithPythagorasFIRectangle:(id<PythagorasFIRectangle>)r {
  return [self containsWithFloat:[((id<PythagorasFIRectangle>) nil_chk(r)) x] withFloat:[((id<PythagorasFIRectangle>) nil_chk(r)) y] withFloat:[((id<PythagorasFIRectangle>) nil_chk(r)) width] withFloat:[((id<PythagorasFIRectangle>) nil_chk(r)) height]];
}

- (BOOL)intersectsWithFloat:(float)x
                  withFloat:(float)y
                  withFloat:(float)width
                  withFloat:(float)height {
  if ((width <= 0.0f) || (height <= 0.0f)) {
    return NO;
  }
  else if (![((PythagorasFRectangle *) nil_chk([self bounds])) intersectsWithFloat:x withFloat:y withFloat:width withFloat:height]) {
    return NO;
  }
  int crossCount = [PythagorasFCrossing intersectShapeWithPythagorasFIShape:self withFloat:x withFloat:y withFloat:width withFloat:height];
  return [PythagorasFCrossing isInsideEvenOddWithInt:crossCount];
}

- (BOOL)intersectsWithPythagorasFIRectangle:(id<PythagorasFIRectangle>)r {
  return [self intersectsWithFloat:[((id<PythagorasFIRectangle>) nil_chk(r)) x] withFloat:[((id<PythagorasFIRectangle>) nil_chk(r)) y] withFloat:[((id<PythagorasFIRectangle>) nil_chk(r)) width] withFloat:[((id<PythagorasFIRectangle>) nil_chk(r)) height]];
}

- (PythagorasFRectangle *)bounds {
  return [self boundsWithPythagorasFRectangle:[[PythagorasFRectangle alloc] init]];
}

- (PythagorasFRectangle *)boundsWithPythagorasFRectangle:(PythagorasFRectangle *)target {
  float maxX = [((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:0], maxY = [((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:1];
  float minX = [((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:0], minY = [((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:1];
  for (int i = 0; i < coordsSize_; ) {
    minX = [JavaLangMath minWithFloat:minX withFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:i]];
    maxX = [JavaLangMath maxWithFloat:maxX withFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:i++]];
    minY = [JavaLangMath minWithFloat:minY withFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:i]];
    maxY = [JavaLangMath maxWithFloat:maxY withFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:i++]];
  }
  return [[PythagorasFRectangle alloc] initWithFloat:minX withFloat:minY withFloat:maxX - minX withFloat:maxY - minY];
}

- (id<PythagorasFPathIterator>)pathIteratorWithPythagorasFTransform:(id<PythagorasFTransform>)t {
  return [[PythagorasFArea_AreaPathIterator alloc] initWithPythagorasFArea:self withPythagorasFTransform:t];
}

- (id<PythagorasFPathIterator>)pathIteratorWithPythagorasFTransform:(id<PythagorasFTransform>)t
                                                          withFloat:(float)flatness {
  return [[PythagorasFFlatteningPathIterator alloc] initWithPythagorasFPathIterator:[self pathIteratorWithPythagorasFTransform:t] withFloat:flatness];
}

- (BOOL)isEqual:(id)obj {
  if (self == obj) {
    return YES;
  }
  else if (!([obj isKindOfClass:[PythagorasFArea class]])) {
    return NO;
  }
  PythagorasFArea *area = [self clone];
  [((PythagorasFArea *) nil_chk(area)) subtractWithPythagorasFArea:(PythagorasFArea *) obj];
  return [((PythagorasFArea *) nil_chk(area)) isEmpty];
}

- (PythagorasFArea *)clone {
  PythagorasFArea *area = [[PythagorasFArea alloc] init];
  [self copy__WithPythagorasFArea:self withPythagorasFArea:area];
  return area;
}

- (void)addCurvePolygonWithPythagorasFArea:(PythagorasFArea *)area {
  PythagorasFCurveCrossingHelper *crossHelper = [[PythagorasFCurveCrossingHelper alloc] initWithFloatArray2:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasFArea *) nil_chk(area)).coords } count:2 type:[IOSFloatArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasFArea *) nil_chk(area)).coordsSize } count:2] withIntArray2:[IOSObjectArray arrayWithObjects:(id[]){ rules_, ((PythagorasFArea *) nil_chk(area)).rules } count:2 type:[IOSIntArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ rulesSize_, ((PythagorasFArea *) nil_chk(area)).rulesSize } count:2] withIntArray2:[IOSObjectArray arrayWithObjects:(id[]){ offsets_, ((PythagorasFArea *) nil_chk(area)).offsets } count:2 type:[IOSIntArray iosClass]]];
  IOSObjectArray *intersectPoints = [((PythagorasFCurveCrossingHelper *) nil_chk(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) nil_chk(intersectPoints)) count] == 0) {
    if ([((PythagorasFArea *) nil_chk(area)) containsWithPythagorasFIRectangle:[self bounds]]) {
      [self copy__WithPythagorasFArea:area withPythagorasFArea:self];
    }
    else if (![self containsWithPythagorasFIRectangle:[((PythagorasFArea *) nil_chk(area)) bounds]]) {
      coords_ = [PythagorasFArea adjustSizeWithFloatArray:coords_ withInt:coordsSize_ + ((PythagorasFArea *) nil_chk(area)).coordsSize];
      [JavaLangSystem arraycopyWithId:((PythagorasFArea *) nil_chk(area)).coords withInt:0 withId:coords_ withInt:coordsSize_ withInt:((PythagorasFArea *) nil_chk(area)).coordsSize];
      coordsSize_ += ((PythagorasFArea *) nil_chk(area)).coordsSize;
      rules_ = [PythagorasFArea adjustSizeWithIntArray:rules_ withInt:rulesSize_ + ((PythagorasFArea *) nil_chk(area)).rulesSize];
      [JavaLangSystem arraycopyWithId:((PythagorasFArea *) nil_chk(area)).rules withInt:0 withId:rules_ withInt:rulesSize_ withInt:((PythagorasFArea *) nil_chk(area)).rulesSize];
      rulesSize_ += ((PythagorasFArea *) nil_chk(area)).rulesSize;
      offsets_ = [PythagorasFArea adjustSizeWithIntArray:offsets_ withInt:rulesSize_ + ((PythagorasFArea *) nil_chk(area)).rulesSize];
      [JavaLangSystem arraycopyWithId:((PythagorasFArea *) nil_chk(area)).offsets withInt:0 withId:offsets_ withInt:rulesSize_ withInt:((PythagorasFArea *) nil_chk(area)).rulesSize];
    }
    return;
  }
  IOSFloatArray *resultCoords = [IOSFloatArray arrayWithLength:coordsSize_ + ((PythagorasFArea *) nil_chk(area)).coordsSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultRules = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasFArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultOffsets = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasFArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasFIntersectPoint *point = [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0];
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_MOVETO;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
  do {
    (*[((IOSFloatArray *) nil_chk(resultCoords)) floatRefAtIndex:resultCoordPos++]) = [((PythagorasFIntersectPoint *) nil_chk(point)) x];
    (*[((IOSFloatArray *) nil_chk(resultCoords)) floatRefAtIndex:resultCoordPos++]) = [((PythagorasFIntersectPoint *) nil_chk(point)) y];
    int curIndex = [((PythagorasFIntersectPoint *) nil_chk(point)) endIndexWithBOOL:YES];
    if (curIndex < 0) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasFArea *) nil_chk(area)) containsExactWithFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex] withFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = NO;
    }
    else {
      isCurrentArea = YES;
    }
    PythagorasFIntersectPoint *nextPoint = [self nextIntersectPointWithPythagorasFIntersectPointArray:intersectPoints withPythagorasFIntersectPoint:point withBOOL:isCurrentArea];
    IOSFloatArray *coords = (isCurrentArea) ? self.coords : ((PythagorasFArea *) nil_chk(area)).coords;
    IOSIntArray *offsets = (isCurrentArea) ? self.offsets : ((PythagorasFArea *) nil_chk(area)).offsets;
    IOSIntArray *rules = (isCurrentArea) ? self.rules : ((PythagorasFArea *) nil_chk(area)).rules;
    int offset = [((PythagorasFIntersectPoint *) nil_chk(point)) ruleIndexWithBOOL:isCurrentArea];
    BOOL isCopyUntilZero = NO;
    if (([((PythagorasFIntersectPoint *) nil_chk(point)) ruleIndexWithBOOL:isCurrentArea] > [((PythagorasFIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea])) {
      int rulesSize = (isCurrentArea) ? self.rulesSize : ((PythagorasFArea *) nil_chk(area)).rulesSize;
      resultCoordPos = [self includeCoordsAndRulesWithInt:offset + 1 withInt:rulesSize withIntArray:rules withIntArray:offsets withIntArray:resultRules withIntArray:resultOffsets withFloatArray:resultCoords withFloatArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasFIntersectPoint:point withBOOL:isCurrentArea withBOOL:NO withInt:0];
      resultRulesPos += rulesSize - offset - 1;
      offset = 1;
      isCopyUntilZero = YES;
    }
    int length = [((PythagorasFIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea] - offset + 1;
    if (isCopyUntilZero) {
      offset = 0;
    }
    resultCoordPos = [self includeCoordsAndRulesWithInt:offset withInt:length withIntArray:rules withIntArray:offsets withIntArray:resultRules withIntArray:resultOffsets withFloatArray:resultCoords withFloatArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasFIntersectPoint:point withBOOL:isCurrentArea withBOOL:YES withInt:0];
    resultRulesPos += length - offset;
    point = nextPoint;
  }
  while (point != [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0]);
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos++]) = PythagorasFPathIterator_SEG_CLOSE;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos - 1]) = resultCoordPos;
  self.coords = resultCoords;
  self.rules = resultRules;
  self.offsets = resultOffsets;
  self.coordsSize = resultCoordPos;
  self.rulesSize = resultRulesPos;
}

- (void)addPolygonWithPythagorasFArea:(PythagorasFArea *)area {
  PythagorasFCrossingHelper *crossHelper = [[PythagorasFCrossingHelper alloc] initWithFloatArray2:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasFArea *) nil_chk(area)).coords } count:2 type:[IOSFloatArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasFArea *) nil_chk(area)).coordsSize } count:2]];
  IOSObjectArray *intersectPoints = [((PythagorasFCrossingHelper *) nil_chk(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) nil_chk(intersectPoints)) count] == 0) {
    if ([((PythagorasFArea *) nil_chk(area)) containsWithPythagorasFIRectangle:[self bounds]]) {
      [self copy__WithPythagorasFArea:area withPythagorasFArea:self];
    }
    else if (![self containsWithPythagorasFIRectangle:[((PythagorasFArea *) nil_chk(area)) bounds]]) {
      coords_ = [PythagorasFArea adjustSizeWithFloatArray:coords_ withInt:coordsSize_ + ((PythagorasFArea *) nil_chk(area)).coordsSize];
      [JavaLangSystem arraycopyWithId:((PythagorasFArea *) nil_chk(area)).coords withInt:0 withId:coords_ withInt:coordsSize_ withInt:((PythagorasFArea *) nil_chk(area)).coordsSize];
      coordsSize_ += ((PythagorasFArea *) nil_chk(area)).coordsSize;
      rules_ = [PythagorasFArea adjustSizeWithIntArray:rules_ withInt:rulesSize_ + ((PythagorasFArea *) nil_chk(area)).rulesSize];
      [JavaLangSystem arraycopyWithId:((PythagorasFArea *) nil_chk(area)).rules withInt:0 withId:rules_ withInt:rulesSize_ withInt:((PythagorasFArea *) nil_chk(area)).rulesSize];
      rulesSize_ += ((PythagorasFArea *) nil_chk(area)).rulesSize;
      offsets_ = [PythagorasFArea adjustSizeWithIntArray:offsets_ withInt:rulesSize_ + ((PythagorasFArea *) nil_chk(area)).rulesSize];
      [JavaLangSystem arraycopyWithId:((PythagorasFArea *) nil_chk(area)).offsets withInt:0 withId:offsets_ withInt:rulesSize_ withInt:((PythagorasFArea *) nil_chk(area)).rulesSize];
    }
    return;
  }
  IOSFloatArray *resultCoords = [IOSFloatArray arrayWithLength:coordsSize_ + ((PythagorasFArea *) nil_chk(area)).coordsSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultRules = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasFArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultOffsets = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasFArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasFIntersectPoint *point = [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0];
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_MOVETO;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
  do {
    (*[((IOSFloatArray *) nil_chk(resultCoords)) floatRefAtIndex:resultCoordPos++]) = [((PythagorasFIntersectPoint *) nil_chk(point)) x];
    (*[((IOSFloatArray *) nil_chk(resultCoords)) floatRefAtIndex:resultCoordPos++]) = [((PythagorasFIntersectPoint *) nil_chk(point)) y];
    (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_LINETO;
    (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos - 2;
    int curIndex = [((PythagorasFIntersectPoint *) nil_chk(point)) endIndexWithBOOL:YES];
    if (curIndex < 0) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasFArea *) nil_chk(area)) containsExactWithFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex] withFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = NO;
    }
    else {
      isCurrentArea = YES;
    }
    PythagorasFIntersectPoint *nextPoint = [self nextIntersectPointWithPythagorasFIntersectPointArray:intersectPoints withPythagorasFIntersectPoint:point withBOOL:isCurrentArea];
    IOSFloatArray *coords = (isCurrentArea) ? self.coords : ((PythagorasFArea *) nil_chk(area)).coords;
    int offset = 2 * [((PythagorasFIntersectPoint *) nil_chk(point)) endIndexWithBOOL:isCurrentArea];
    if ((offset >= 0) && ([((PythagorasFIntersectPoint *) nil_chk(nextPoint)) begIndexWithBOOL:isCurrentArea] < [((PythagorasFIntersectPoint *) nil_chk(point)) endIndexWithBOOL:isCurrentArea])) {
      int coordSize = (isCurrentArea) ? self.coordsSize : ((PythagorasFArea *) nil_chk(area)).coordsSize;
      int length = coordSize - offset;
      [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      for (int i = 0; i < length / 2; i++) {
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_LINETO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
        resultCoordPos += 2;
      }
      offset = 0;
    }
    if (offset >= 0) {
      int length = 2 * [((PythagorasFIntersectPoint *) nil_chk(nextPoint)) begIndexWithBOOL:isCurrentArea] - offset + 2;
      [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      for (int i = 0; i < length / 2; i++) {
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_LINETO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
        resultCoordPos += 2;
      }
    }
    point = nextPoint;
  }
  while (point != [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0]);
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos - 1]) = PythagorasFPathIterator_SEG_CLOSE;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos - 1]) = resultCoordPos;
  coords_ = resultCoords;
  rules_ = resultRules;
  offsets_ = resultOffsets;
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (void)intersectCurvePolygonWithPythagorasFArea:(PythagorasFArea *)area {
  PythagorasFCurveCrossingHelper *crossHelper = [[PythagorasFCurveCrossingHelper alloc] initWithFloatArray2:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasFArea *) nil_chk(area)).coords } count:2 type:[IOSFloatArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasFArea *) nil_chk(area)).coordsSize } count:2] withIntArray2:[IOSObjectArray arrayWithObjects:(id[]){ rules_, ((PythagorasFArea *) nil_chk(area)).rules } count:2 type:[IOSIntArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ rulesSize_, ((PythagorasFArea *) nil_chk(area)).rulesSize } count:2] withIntArray2:[IOSObjectArray arrayWithObjects:(id[]){ offsets_, ((PythagorasFArea *) nil_chk(area)).offsets } count:2 type:[IOSIntArray iosClass]]];
  IOSObjectArray *intersectPoints = [((PythagorasFCurveCrossingHelper *) nil_chk(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) nil_chk(intersectPoints)) count] == 0) {
    if ([self containsWithPythagorasFIRectangle:[((PythagorasFArea *) nil_chk(area)) bounds]]) {
      [self copy__WithPythagorasFArea:area withPythagorasFArea:self];
    }
    else if (![((PythagorasFArea *) nil_chk(area)) containsWithPythagorasFIRectangle:[self bounds]]) {
      [self reset];
    }
    return;
  }
  IOSFloatArray *resultCoords = [IOSFloatArray arrayWithLength:coordsSize_ + ((PythagorasFArea *) nil_chk(area)).coordsSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultRules = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasFArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultOffsets = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasFArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasFIntersectPoint *point = [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0];
  PythagorasFIntersectPoint *nextPoint = [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0];
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_MOVETO;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
  do {
    (*[((IOSFloatArray *) nil_chk(resultCoords)) floatRefAtIndex:resultCoordPos++]) = [((PythagorasFIntersectPoint *) nil_chk(point)) x];
    (*[((IOSFloatArray *) nil_chk(resultCoords)) floatRefAtIndex:resultCoordPos++]) = [((PythagorasFIntersectPoint *) nil_chk(point)) y];
    int curIndex = [((PythagorasFIntersectPoint *) nil_chk(point)) endIndexWithBOOL:YES];
    if ((curIndex < 0) || ([((PythagorasFArea *) nil_chk(area)) containsExactWithFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex] withFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex + 1]] == 0)) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasFArea *) nil_chk(area)) containsExactWithFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex] withFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = YES;
    }
    else {
      isCurrentArea = NO;
    }
    nextPoint = [self nextIntersectPointWithPythagorasFIntersectPointArray:intersectPoints withPythagorasFIntersectPoint:point withBOOL:isCurrentArea];
    IOSFloatArray *coords = (isCurrentArea) ? self.coords : ((PythagorasFArea *) nil_chk(area)).coords;
    IOSIntArray *offsets = (isCurrentArea) ? self.offsets : ((PythagorasFArea *) nil_chk(area)).offsets;
    IOSIntArray *rules = (isCurrentArea) ? self.rules : ((PythagorasFArea *) nil_chk(area)).rules;
    int offset = [((PythagorasFIntersectPoint *) nil_chk(point)) ruleIndexWithBOOL:isCurrentArea];
    BOOL isCopyUntilZero = NO;
    if ([((PythagorasFIntersectPoint *) nil_chk(point)) ruleIndexWithBOOL:isCurrentArea] > [((PythagorasFIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea]) {
      int rulesSize = (isCurrentArea) ? self.rulesSize : ((PythagorasFArea *) nil_chk(area)).rulesSize;
      resultCoordPos = [self includeCoordsAndRulesWithInt:offset + 1 withInt:rulesSize withIntArray:rules withIntArray:offsets withIntArray:resultRules withIntArray:resultOffsets withFloatArray:resultCoords withFloatArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasFIntersectPoint:point withBOOL:isCurrentArea withBOOL:NO withInt:1];
      resultRulesPos += rulesSize - offset - 1;
      offset = 1;
      isCopyUntilZero = YES;
    }
    int length = [((PythagorasFIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea] - offset + 1;
    if (isCopyUntilZero) {
      offset = 0;
      isCopyUntilZero = NO;
    }
    if ((length == offset) && ([((PythagorasFIntersectPoint *) nil_chk(nextPoint)) ruleWithBOOL:isCurrentArea] != PythagorasFPathIterator_SEG_LINETO) && ([((PythagorasFIntersectPoint *) nil_chk(nextPoint)) ruleWithBOOL:isCurrentArea] != PythagorasFPathIterator_SEG_CLOSE) && ([((PythagorasFIntersectPoint *) nil_chk(point)) ruleWithBOOL:isCurrentArea] != PythagorasFPathIterator_SEG_LINETO) && ([((PythagorasFIntersectPoint *) nil_chk(point)) ruleWithBOOL:isCurrentArea] != PythagorasFPathIterator_SEG_CLOSE)) {
      isCopyUntilZero = YES;
      length++;
    }
    resultCoordPos = [self includeCoordsAndRulesWithInt:offset withInt:length withIntArray:rules withIntArray:offsets withIntArray:resultRules withIntArray:resultOffsets withFloatArray:resultCoords withFloatArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasFIntersectPoint:nextPoint withBOOL:isCurrentArea withBOOL:YES withInt:1];
    resultRulesPos = ((length <= offset) || (isCopyUntilZero)) ? resultRulesPos + 1 : resultRulesPos + length;
    point = nextPoint;
  }
  while (point != [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0]);
  if ([((IOSIntArray *) nil_chk(resultRules)) intAtIndex:resultRulesPos - 1] == PythagorasFPathIterator_SEG_LINETO) {
    (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos - 1]) = PythagorasFPathIterator_SEG_CLOSE;
  }
  else {
    (*[((IOSFloatArray *) nil_chk(resultCoords)) floatRefAtIndex:resultCoordPos++]) = [((PythagorasFIntersectPoint *) nil_chk(nextPoint)) x];
    (*[((IOSFloatArray *) nil_chk(resultCoords)) floatRefAtIndex:resultCoordPos++]) = [((PythagorasFIntersectPoint *) nil_chk(nextPoint)) y];
    (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos++]) = PythagorasFPathIterator_SEG_CLOSE;
  }
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos - 1]) = resultCoordPos;
  coords_ = resultCoords;
  rules_ = resultRules;
  offsets_ = resultOffsets;
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (void)intersectPolygonWithPythagorasFArea:(PythagorasFArea *)area {
  PythagorasFCrossingHelper *crossHelper = [[PythagorasFCrossingHelper alloc] initWithFloatArray2:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasFArea *) nil_chk(area)).coords } count:2 type:[IOSFloatArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasFArea *) nil_chk(area)).coordsSize } count:2]];
  IOSObjectArray *intersectPoints = [((PythagorasFCrossingHelper *) nil_chk(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) nil_chk(intersectPoints)) count] == 0) {
    if ([self containsWithPythagorasFIRectangle:[((PythagorasFArea *) nil_chk(area)) bounds]]) {
      [self copy__WithPythagorasFArea:area withPythagorasFArea:self];
    }
    else if (![((PythagorasFArea *) nil_chk(area)) containsWithPythagorasFIRectangle:[self bounds]]) {
      [self reset];
    }
    return;
  }
  IOSFloatArray *resultCoords = [IOSFloatArray arrayWithLength:coordsSize_ + ((PythagorasFArea *) nil_chk(area)).coordsSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultRules = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasFArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultOffsets = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasFArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasFIntersectPoint *point = [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0];
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_MOVETO;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
  do {
    (*[((IOSFloatArray *) nil_chk(resultCoords)) floatRefAtIndex:resultCoordPos++]) = [((PythagorasFIntersectPoint *) nil_chk(point)) x];
    (*[((IOSFloatArray *) nil_chk(resultCoords)) floatRefAtIndex:resultCoordPos++]) = [((PythagorasFIntersectPoint *) nil_chk(point)) y];
    (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_LINETO;
    (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos - 2;
    int curIndex = [((PythagorasFIntersectPoint *) nil_chk(point)) endIndexWithBOOL:YES];
    if ((curIndex < 0) || ([((PythagorasFArea *) nil_chk(area)) containsExactWithFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex] withFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex + 1]] == 0)) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasFArea *) nil_chk(area)) containsExactWithFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex] withFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = YES;
    }
    else {
      isCurrentArea = NO;
    }
    PythagorasFIntersectPoint *nextPoint = [self nextIntersectPointWithPythagorasFIntersectPointArray:intersectPoints withPythagorasFIntersectPoint:point withBOOL:isCurrentArea];
    IOSFloatArray *coords = (isCurrentArea) ? self.coords : ((PythagorasFArea *) nil_chk(area)).coords;
    int offset = 2 * [((PythagorasFIntersectPoint *) nil_chk(point)) endIndexWithBOOL:isCurrentArea];
    if ((offset >= 0) && ([((PythagorasFIntersectPoint *) nil_chk(nextPoint)) begIndexWithBOOL:isCurrentArea] < [((PythagorasFIntersectPoint *) nil_chk(point)) endIndexWithBOOL:isCurrentArea])) {
      int coordSize = (isCurrentArea) ? self.coordsSize : ((PythagorasFArea *) nil_chk(area)).coordsSize;
      int length = coordSize - offset;
      [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      for (int i = 0; i < length / 2; i++) {
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_LINETO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
        resultCoordPos += 2;
      }
      offset = 0;
    }
    if (offset >= 0) {
      int length = 2 * [((PythagorasFIntersectPoint *) nil_chk(nextPoint)) begIndexWithBOOL:isCurrentArea] - offset + 2;
      [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      for (int i = 0; i < length / 2; i++) {
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_LINETO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
        resultCoordPos += 2;
      }
    }
    point = nextPoint;
  }
  while (point != [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0]);
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos - 1]) = PythagorasFPathIterator_SEG_CLOSE;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos - 1]) = resultCoordPos;
  coords_ = resultCoords;
  rules_ = resultRules;
  offsets_ = resultOffsets;
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (void)subtractCurvePolygonWithPythagorasFArea:(PythagorasFArea *)area {
  PythagorasFCurveCrossingHelper *crossHelper = [[PythagorasFCurveCrossingHelper alloc] initWithFloatArray2:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasFArea *) nil_chk(area)).coords } count:2 type:[IOSFloatArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasFArea *) nil_chk(area)).coordsSize } count:2] withIntArray2:[IOSObjectArray arrayWithObjects:(id[]){ rules_, ((PythagorasFArea *) nil_chk(area)).rules } count:2 type:[IOSIntArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ rulesSize_, ((PythagorasFArea *) nil_chk(area)).rulesSize } count:2] withIntArray2:[IOSObjectArray arrayWithObjects:(id[]){ offsets_, ((PythagorasFArea *) nil_chk(area)).offsets } count:2 type:[IOSIntArray iosClass]]];
  IOSObjectArray *intersectPoints = [((PythagorasFCurveCrossingHelper *) nil_chk(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) nil_chk(intersectPoints)) count] == 0 && [self containsWithPythagorasFIRectangle:[((PythagorasFArea *) nil_chk(area)) bounds]]) {
    [self copy__WithPythagorasFArea:area withPythagorasFArea:self];
    return;
  }
  IOSFloatArray *resultCoords = [IOSFloatArray arrayWithLength:coordsSize_ + ((PythagorasFArea *) nil_chk(area)).coordsSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultRules = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasFArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  IOSIntArray *resultOffsets = [IOSIntArray arrayWithLength:rulesSize_ + ((PythagorasFArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasFIntersectPoint *point = [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0];
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_MOVETO;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
  do {
    (*[((IOSFloatArray *) nil_chk(resultCoords)) floatRefAtIndex:resultCoordPos++]) = [((PythagorasFIntersectPoint *) nil_chk(point)) x];
    (*[((IOSFloatArray *) nil_chk(resultCoords)) floatRefAtIndex:resultCoordPos++]) = [((PythagorasFIntersectPoint *) nil_chk(point)) y];
    int curIndex = [((IOSIntArray *) nil_chk(offsets_)) intAtIndex:[((PythagorasFIntersectPoint *) nil_chk(point)) ruleIndexWithBOOL:YES]] % coordsSize_;
    if ([((PythagorasFArea *) nil_chk(area)) containsExactWithFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:curIndex] withFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:curIndex + 1]] == 0) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasFArea *) nil_chk(area)) containsExactWithFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:curIndex] withFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:curIndex + 1]] > 0) {
      isCurrentArea = NO;
    }
    else {
      isCurrentArea = YES;
    }
    PythagorasFIntersectPoint *nextPoint = (isCurrentArea) ? [self nextIntersectPointWithPythagorasFIntersectPointArray:intersectPoints withPythagorasFIntersectPoint:point withBOOL:isCurrentArea] : [self prevIntersectPointWithPythagorasFIntersectPointArray:intersectPoints withPythagorasFIntersectPoint:point withBOOL:isCurrentArea];
    IOSFloatArray *coords = (isCurrentArea) ? self.coords : ((PythagorasFArea *) nil_chk(area)).coords;
    IOSIntArray *offsets = (isCurrentArea) ? self.offsets : ((PythagorasFArea *) nil_chk(area)).offsets;
    IOSIntArray *rules = (isCurrentArea) ? self.rules : ((PythagorasFArea *) nil_chk(area)).rules;
    int offset = (isCurrentArea) ? [((PythagorasFIntersectPoint *) nil_chk(point)) ruleIndexWithBOOL:isCurrentArea] : [((PythagorasFIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea];
    BOOL isCopyUntilZero = NO;
    if (((isCurrentArea) && ([((PythagorasFIntersectPoint *) nil_chk(point)) ruleIndexWithBOOL:isCurrentArea] > [((PythagorasFIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea])) || ((!isCurrentArea) && ([((PythagorasFIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea] > [((PythagorasFIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea]))) {
      int rulesSize = (isCurrentArea) ? self.rulesSize : ((PythagorasFArea *) nil_chk(area)).rulesSize;
      resultCoordPos = [self includeCoordsAndRulesWithInt:offset + 1 withInt:rulesSize withIntArray:rules withIntArray:offsets withIntArray:resultRules withIntArray:resultOffsets withFloatArray:resultCoords withFloatArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasFIntersectPoint:point withBOOL:isCurrentArea withBOOL:NO withInt:2];
      resultRulesPos += rulesSize - offset - 1;
      offset = 1;
      isCopyUntilZero = YES;
    }
    int length = [((PythagorasFIntersectPoint *) nil_chk(nextPoint)) ruleIndexWithBOOL:isCurrentArea] - offset + 1;
    if (isCopyUntilZero) {
      offset = 0;
      isCopyUntilZero = NO;
    }
    resultCoordPos = [self includeCoordsAndRulesWithInt:offset withInt:length withIntArray:rules withIntArray:offsets withIntArray:resultRules withIntArray:resultOffsets withFloatArray:resultCoords withFloatArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasFIntersectPoint:point withBOOL:isCurrentArea withBOOL:YES withInt:2];
    if ((length == offset) && (([((IOSIntArray *) nil_chk(rules)) intAtIndex:offset] == PythagorasFPathIterator_SEG_QUADTO) || ([((IOSIntArray *) nil_chk(rules)) intAtIndex:offset] == PythagorasFPathIterator_SEG_CUBICTO))) {
      resultRulesPos++;
    }
    else {
      resultRulesPos = (length < offset || isCopyUntilZero) ? resultRulesPos + 1 : resultRulesPos + length - offset;
    }
    point = nextPoint;
  }
  while (point != [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0]);
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos++]) = PythagorasFPathIterator_SEG_CLOSE;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos - 1]) = resultCoordPos;
  coords_ = resultCoords;
  rules_ = resultRules;
  offsets_ = resultOffsets;
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (void)subtractPolygonWithPythagorasFArea:(PythagorasFArea *)area {
  PythagorasFCrossingHelper *crossHelper = [[PythagorasFCrossingHelper alloc] initWithFloatArray2:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasFArea *) nil_chk(area)).coords } count:2 type:[IOSFloatArray iosClass]] withIntArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasFArea *) nil_chk(area)).coordsSize } count:2]];
  IOSObjectArray *intersectPoints = [((PythagorasFCrossingHelper *) nil_chk(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) nil_chk(intersectPoints)) count] == 0) {
    if ([self containsWithPythagorasFIRectangle:[((PythagorasFArea *) nil_chk(area)) bounds]]) {
      [self copy__WithPythagorasFArea:area withPythagorasFArea:self];
      return;
    }
    return;
  }
  IOSFloatArray *resultCoords = [IOSFloatArray arrayWithLength:2 * (coordsSize_ + ((PythagorasFArea *) nil_chk(area)).coordsSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count])];
  IOSIntArray *resultRules = [IOSIntArray arrayWithLength:2 * (rulesSize_ + ((PythagorasFArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count])];
  IOSIntArray *resultOffsets = [IOSIntArray arrayWithLength:2 * (rulesSize_ + ((PythagorasFArea *) nil_chk(area)).rulesSize + (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count])];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  int countPoints = 0;
  BOOL curArea = NO;
  BOOL addArea = NO;
  PythagorasFIntersectPoint *point = [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0];
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_MOVETO;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
  do {
    (*[((IOSFloatArray *) nil_chk(resultCoords)) floatRefAtIndex:resultCoordPos++]) = [((PythagorasFIntersectPoint *) nil_chk(point)) x];
    (*[((IOSFloatArray *) nil_chk(resultCoords)) floatRefAtIndex:resultCoordPos++]) = [((PythagorasFIntersectPoint *) nil_chk(point)) y];
    (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_LINETO;
    (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos - 2;
    int curIndex = [((PythagorasFIntersectPoint *) nil_chk(point)) endIndexWithBOOL:YES];
    if ((curIndex < 0) || ([((PythagorasFArea *) nil_chk(area)) isVertexWithFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex] withFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex + 1]] && [((PythagorasFCrossingHelper *) nil_chk(crossHelper)) containsPointWithFloatArray:[IOSFloatArray arrayWithFloats:(float[]){ [((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex], [((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex + 1] } count:2]] && ([((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex] != [((PythagorasFIntersectPoint *) nil_chk(point)) x] || [((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex + 1] != [((PythagorasFIntersectPoint *) nil_chk(point)) y]))) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasFArea *) nil_chk(area)) containsExactWithFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex] withFloat:[((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = NO;
    }
    else {
      isCurrentArea = YES;
    }
    if (countPoints >= (int) [((IOSObjectArray *) nil_chk(intersectPoints)) count]) {
      isCurrentArea = !isCurrentArea;
    }
    if (isCurrentArea) {
      curArea = YES;
    }
    else {
      addArea = YES;
    }
    PythagorasFIntersectPoint *nextPoint = (isCurrentArea) ? [self nextIntersectPointWithPythagorasFIntersectPointArray:intersectPoints withPythagorasFIntersectPoint:point withBOOL:isCurrentArea] : [self prevIntersectPointWithPythagorasFIntersectPointArray:intersectPoints withPythagorasFIntersectPoint:point withBOOL:isCurrentArea];
    IOSFloatArray *coords = (isCurrentArea) ? self.coords : ((PythagorasFArea *) nil_chk(area)).coords;
    int offset = (isCurrentArea) ? 2 * [((PythagorasFIntersectPoint *) nil_chk(point)) endIndexWithBOOL:isCurrentArea] : 2 * [((PythagorasFIntersectPoint *) nil_chk(nextPoint)) endIndexWithBOOL:isCurrentArea];
    if ((offset > 0) && (((isCurrentArea) && ([((PythagorasFIntersectPoint *) nil_chk(nextPoint)) begIndexWithBOOL:isCurrentArea] < [((PythagorasFIntersectPoint *) nil_chk(point)) endIndexWithBOOL:isCurrentArea])) || ((!isCurrentArea) && ([((PythagorasFIntersectPoint *) nil_chk(nextPoint)) endIndexWithBOOL:isCurrentArea] < [((PythagorasFIntersectPoint *) nil_chk(nextPoint)) begIndexWithBOOL:isCurrentArea])))) {
      int coordSize = (isCurrentArea) ? self.coordsSize : ((PythagorasFArea *) nil_chk(area)).coordsSize;
      int length = coordSize - offset;
      if (isCurrentArea) {
        [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      }
      else {
        IOSFloatArray *temp = [IOSFloatArray arrayWithLength:length];
        [JavaLangSystem arraycopyWithId:coords withInt:offset withId:temp withInt:0 withInt:length];
        [self reverseCopyWithFloatArray:temp];
        [JavaLangSystem arraycopyWithId:temp withInt:0 withId:resultCoords withInt:resultCoordPos withInt:length];
      }
      for (int i = 0; i < length / 2; i++) {
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_LINETO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
        resultCoordPos += 2;
      }
      offset = 0;
    }
    if (offset >= 0) {
      int length = (isCurrentArea) ? 2 * [((PythagorasFIntersectPoint *) nil_chk(nextPoint)) begIndexWithBOOL:isCurrentArea] - offset + 2 : 2 * [((PythagorasFIntersectPoint *) nil_chk(point)) begIndexWithBOOL:isCurrentArea] - offset + 2;
      if (isCurrentArea) {
        [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      }
      else {
        IOSFloatArray *temp = [IOSFloatArray arrayWithLength:length];
        [JavaLangSystem arraycopyWithId:coords withInt:offset withId:temp withInt:0 withInt:length];
        [self reverseCopyWithFloatArray:temp];
        [JavaLangSystem arraycopyWithId:temp withInt:0 withId:resultCoords withInt:resultCoordPos withInt:length];
      }
      for (int i = 0; i < length / 2; i++) {
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_LINETO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos;
        resultCoordPos += 2;
      }
    }
    point = nextPoint;
    countPoints++;
  }
  while (point != [((IOSObjectArray *) nil_chk(intersectPoints)) objectAtIndex:0] || !(curArea && addArea));
  (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos - 1]) = PythagorasFPathIterator_SEG_CLOSE;
  (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos - 1]) = resultCoordPos;
  coords_ = resultCoords;
  rules_ = resultRules;
  offsets_ = resultOffsets;
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (PythagorasFIntersectPoint *)nextIntersectPointWithPythagorasFIntersectPointArray:(IOSObjectArray *)iPoints
                                                      withPythagorasFIntersectPoint:(PythagorasFIntersectPoint *)isectPoint
                                                                           withBOOL:(BOOL)isCurrentArea {
  int endIndex = [((PythagorasFIntersectPoint *) nil_chk(isectPoint)) endIndexWithBOOL:isCurrentArea];
  if (endIndex < 0) {
    return [((IOSObjectArray *) nil_chk(iPoints)) objectAtIndex:[JavaLangMath absWithInt:endIndex] - 1];
  }
  PythagorasFIntersectPoint *firstIsectPoint = nil;
  PythagorasFIntersectPoint *nextIsectPoint = nil;
  {
    IOSObjectArray *a__ = iPoints;
    int n__ = (int) [((IOSObjectArray *) nil_chk(a__)) count];
    for (int i__ = 0; i__ < n__; i__++) {
      PythagorasFIntersectPoint *point = [((IOSObjectArray *) nil_chk(a__)) objectAtIndex:i__];
      int begIndex = [((PythagorasFIntersectPoint *) nil_chk(point)) begIndexWithBOOL:isCurrentArea];
      if (begIndex >= 0) {
        if (firstIsectPoint == nil) {
          firstIsectPoint = point;
        }
        else if (begIndex < [firstIsectPoint begIndexWithBOOL:isCurrentArea]) {
          firstIsectPoint = point;
        }
      }
      if (endIndex <= begIndex) {
        if (nextIsectPoint == nil) {
          nextIsectPoint = point;
        }
        else if (begIndex < [nextIsectPoint begIndexWithBOOL:isCurrentArea]) {
          nextIsectPoint = point;
        }
      }
    }
  }
  return (nextIsectPoint != nil) ? nextIsectPoint : firstIsectPoint;
}

- (PythagorasFIntersectPoint *)prevIntersectPointWithPythagorasFIntersectPointArray:(IOSObjectArray *)iPoints
                                                      withPythagorasFIntersectPoint:(PythagorasFIntersectPoint *)isectPoint
                                                                           withBOOL:(BOOL)isCurrentArea {
  int begIndex = [((PythagorasFIntersectPoint *) nil_chk(isectPoint)) begIndexWithBOOL:isCurrentArea];
  if (begIndex < 0) {
    return [((IOSObjectArray *) nil_chk(iPoints)) objectAtIndex:[JavaLangMath absWithInt:begIndex] - 1];
  }
  PythagorasFIntersectPoint *firstIsectPoint = nil;
  PythagorasFIntersectPoint *predIsectPoint = nil;
  {
    IOSObjectArray *a__ = iPoints;
    int n__ = (int) [((IOSObjectArray *) nil_chk(a__)) count];
    for (int i__ = 0; i__ < n__; i__++) {
      PythagorasFIntersectPoint *point = [((IOSObjectArray *) nil_chk(a__)) objectAtIndex:i__];
      int endIndex = [((PythagorasFIntersectPoint *) nil_chk(point)) endIndexWithBOOL:isCurrentArea];
      if (endIndex >= 0) {
        if (firstIsectPoint == nil) {
          firstIsectPoint = point;
        }
        else if (endIndex < [firstIsectPoint endIndexWithBOOL:isCurrentArea]) {
          firstIsectPoint = point;
        }
      }
      if (endIndex <= begIndex) {
        if (predIsectPoint == nil) {
          predIsectPoint = point;
        }
        else if (endIndex > [predIsectPoint endIndexWithBOOL:isCurrentArea]) {
          predIsectPoint = point;
        }
      }
    }
  }
  return (predIsectPoint != nil) ? predIsectPoint : firstIsectPoint;
}

- (int)includeCoordsAndRulesWithInt:(int)offset
                            withInt:(int)length
                       withIntArray:(IOSIntArray *)rules
                       withIntArray:(IOSIntArray *)offsets
                       withIntArray:(IOSIntArray *)resultRules
                       withIntArray:(IOSIntArray *)resultOffsets
                     withFloatArray:(IOSFloatArray *)resultCoords
                     withFloatArray:(IOSFloatArray *)coords
                            withInt:(int)resultRulesPos
                            withInt:(int)resultCoordPos
      withPythagorasFIntersectPoint:(PythagorasFIntersectPoint *)point
                           withBOOL:(BOOL)isCurrentArea
                           withBOOL:(BOOL)way
                            withInt:(int)operation {
  IOSFloatArray *temp = [IOSFloatArray arrayWithLength:8 * length];
  int coordsCount = 0;
  BOOL isMoveIndex = YES;
  BOOL isMoveLength = YES;
  BOOL additional = NO;
  if (length <= offset) {
    for (int i = resultRulesPos; i < resultRulesPos + 1; i++) {
      (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:i]) = PythagorasFPathIterator_SEG_LINETO;
    }
  }
  else {
    int j = resultRulesPos;
    for (int i = offset; i < length; i++) {
      (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:j++]) = PythagorasFPathIterator_SEG_LINETO;
    }
  }
  if ((length == offset) && (([((IOSIntArray *) nil_chk(rules)) intAtIndex:offset] == PythagorasFPathIterator_SEG_QUADTO) || ([((IOSIntArray *) nil_chk(rules)) intAtIndex:offset] == PythagorasFPathIterator_SEG_CUBICTO))) {
    length++;
    additional = YES;
  }
  for (int i = offset; i < length; i++) {
    int index = [((IOSIntArray *) nil_chk(offsets)) intAtIndex:i];
    if (!isMoveIndex) {
      index -= 2;
    }
    if (!isMoveLength) {
      length++;
      isMoveLength = YES;
    }
    {
      BOOL isLeft;
      IOSFloatArray *coefs;
      switch ([((IOSIntArray *) nil_chk(rules)) intAtIndex:i]) {
        case PythagorasFPathIterator_SEG_MOVETO:
        isMoveIndex = NO;
        isMoveLength = NO;
        break;
        case PythagorasFPathIterator_SEG_LINETO:
        case PythagorasFPathIterator_SEG_CLOSE:
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_LINETO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos + 2;
        isLeft = [PythagorasFCrossingHelper compareWithFloat:[((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index] withFloat:[((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index + 1] withFloat:[((PythagorasFIntersectPoint *) nil_chk(point)) x] withFloat:[((PythagorasFIntersectPoint *) nil_chk(point)) y]] > 0;
        if (way || !isLeft) {
          (*[((IOSFloatArray *) nil_chk(temp)) floatRefAtIndex:coordsCount++]) = [((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index];
          (*[((IOSFloatArray *) nil_chk(temp)) floatRefAtIndex:coordsCount++]) = [((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index + 1];
        }
        break;
        case PythagorasFPathIterator_SEG_QUADTO:
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_QUADTO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos + 4;
        coefs = [IOSFloatArray arrayWithFloats:(float[]){ [((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index - 2], [((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index - 1], [((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index], [((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index + 1], [((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index + 2], [((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index + 3] } count:6];
        isLeft = [PythagorasFCrossingHelper compareWithFloat:[((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index - 2] withFloat:[((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index - 1] withFloat:[((PythagorasFIntersectPoint *) nil_chk(point)) x] withFloat:[((PythagorasFIntersectPoint *) nil_chk(point)) y]] > 0;
        if ((!additional) && (operation == 0 || operation == 2)) {
          isLeft = !isLeft;
          way = NO;
        }
        [PythagorasFGeometryUtil subQuadWithFloatArray:coefs withFloat:[((PythagorasFIntersectPoint *) nil_chk(point)) paramWithBOOL:isCurrentArea] withBOOL:isLeft];
        if (way || isLeft) {
          (*[((IOSFloatArray *) nil_chk(temp)) floatRefAtIndex:coordsCount++]) = [((IOSFloatArray *) nil_chk(coefs)) floatAtIndex:2];
          (*[((IOSFloatArray *) nil_chk(temp)) floatRefAtIndex:coordsCount++]) = [((IOSFloatArray *) nil_chk(coefs)) floatAtIndex:3];
        }
        else {
          [JavaLangSystem arraycopyWithId:coefs withInt:2 withId:temp withInt:coordsCount withInt:4];
          coordsCount += 4;
        }
        break;
        case PythagorasFPathIterator_SEG_CUBICTO:
        (*[((IOSIntArray *) nil_chk(resultRules)) intRefAtIndex:resultRulesPos]) = PythagorasFPathIterator_SEG_CUBICTO;
        (*[((IOSIntArray *) nil_chk(resultOffsets)) intRefAtIndex:resultRulesPos++]) = resultCoordPos + 6;
        coefs = [IOSFloatArray arrayWithFloats:(float[]){ [((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index - 2], [((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index - 1], [((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index], [((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index + 1], [((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index + 2], [((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index + 3], [((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index + 4], [((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index + 5] } count:8];
        isLeft = [PythagorasFCrossingHelper compareWithFloat:[((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index - 2] withFloat:[((IOSFloatArray *) nil_chk(coords)) floatAtIndex:index - 1] withFloat:[((PythagorasFIntersectPoint *) nil_chk(point)) x] withFloat:[((PythagorasFIntersectPoint *) nil_chk(point)) y]] > 0;
        [PythagorasFGeometryUtil subCubicWithFloatArray:coefs withFloat:[((PythagorasFIntersectPoint *) nil_chk(point)) paramWithBOOL:isCurrentArea] withBOOL:!isLeft];
        if (isLeft) {
          [JavaLangSystem arraycopyWithId:coefs withInt:2 withId:temp withInt:coordsCount withInt:6];
          coordsCount += 6;
        }
        else {
          [JavaLangSystem arraycopyWithId:coefs withInt:2 withId:temp withInt:coordsCount withInt:4];
          coordsCount += 4;
        }
        break;
      }
    }
  }
  if (operation == 2 && !isCurrentArea && coordsCount > 2) {
    [self reverseCopyWithFloatArray:temp];
    [JavaLangSystem arraycopyWithId:temp withInt:0 withId:resultCoords withInt:resultCoordPos withInt:coordsCount];
  }
  else {
    [JavaLangSystem arraycopyWithId:temp withInt:0 withId:resultCoords withInt:resultCoordPos withInt:coordsCount];
  }
  return (resultCoordPos + coordsCount);
}

- (void)copy__WithPythagorasFArea:(PythagorasFArea *)src
              withPythagorasFArea:(PythagorasFArea *)dst OBJC_METHOD_FAMILY_NONE {
  ((PythagorasFArea *) nil_chk(dst)).coordsSize = ((PythagorasFArea *) nil_chk(src)).coordsSize;
  ((PythagorasFArea *) nil_chk(dst)).coords = [PythagorasUtilPlatform cloneWithFloatArray:((PythagorasFArea *) nil_chk(src)).coords];
  ((PythagorasFArea *) nil_chk(dst)).rulesSize = ((PythagorasFArea *) nil_chk(src)).rulesSize;
  ((PythagorasFArea *) nil_chk(dst)).rules = [PythagorasUtilPlatform cloneWithIntArray:((PythagorasFArea *) nil_chk(src)).rules];
  ((PythagorasFArea *) nil_chk(dst)).moveToCount = ((PythagorasFArea *) nil_chk(src)).moveToCount;
  ((PythagorasFArea *) nil_chk(dst)).offsets = [PythagorasUtilPlatform cloneWithIntArray:((PythagorasFArea *) nil_chk(src)).offsets];
}

- (int)containsExactWithFloat:(float)x
                    withFloat:(float)y {
  id<PythagorasFPathIterator> pi = [self pathIteratorWithPythagorasFTransform:nil];
  int crossCount = [PythagorasFCrossing crossPathWithPythagorasFPathIterator:pi withFloat:x withFloat:y];
  if ([PythagorasFCrossing isInsideEvenOddWithInt:crossCount]) {
    return 1;
  }
  IOSFloatArray *segmentCoords = [IOSFloatArray arrayWithLength:6];
  IOSFloatArray *resultPoints = [IOSFloatArray arrayWithLength:6];
  int rule;
  float curX = -1;
  float curY = -1;
  float moveX = -1;
  float moveY = -1;
  for (pi = [self pathIteratorWithPythagorasFTransform:nil]; ![((id<PythagorasFPathIterator>) nil_chk(pi)) isDone]; [((id<PythagorasFPathIterator>) nil_chk(pi)) next]) {
    rule = [((id<PythagorasFPathIterator>) nil_chk(pi)) currentSegmentWithFloatArray:segmentCoords];
    switch (rule) {
      case PythagorasFPathIterator_SEG_MOVETO:
      moveX = curX = [((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:0];
      moveY = curY = [((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:1];
      break;
      case PythagorasFPathIterator_SEG_LINETO:
      if ([PythagorasFGeometryUtil intersectLinesWithFloat:curX withFloat:curY withFloat:[((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:0] withFloat:[((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:1] withFloat:x withFloat:y withFloat:x withFloat:y withFloatArray:resultPoints] != 0) {
        return 0;
      }
      curX = [((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:0];
      curY = [((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:1];
      break;
      case PythagorasFPathIterator_SEG_QUADTO:
      if ([PythagorasFGeometryUtil intersectLineAndQuadWithFloat:x withFloat:y withFloat:x withFloat:y withFloat:curX withFloat:curY withFloat:[((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:0] withFloat:[((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:1] withFloat:[((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:2] withFloat:[((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:3] withFloatArray:resultPoints] > 0) {
        return 0;
      }
      curX = [((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:2];
      curY = [((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:3];
      break;
      case PythagorasFPathIterator_SEG_CUBICTO:
      if ([PythagorasFGeometryUtil intersectLineAndCubicWithFloat:x withFloat:y withFloat:x withFloat:y withFloat:curX withFloat:curY withFloat:[((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:0] withFloat:[((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:1] withFloat:[((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:2] withFloat:[((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:3] withFloat:[((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:4] withFloat:[((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:5] withFloatArray:resultPoints] > 0) {
        return 0;
      }
      curX = [((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:4];
      curY = [((IOSFloatArray *) nil_chk(segmentCoords)) floatAtIndex:5];
      break;
      case PythagorasFPathIterator_SEG_CLOSE:
      if ([PythagorasFGeometryUtil intersectLinesWithFloat:curX withFloat:curY withFloat:moveX withFloat:moveY withFloat:x withFloat:y withFloat:x withFloat:y withFloatArray:resultPoints] != 0) {
        return 0;
      }
      curX = moveX;
      curY = moveY;
      break;
    }
  }
  return -1;
}

- (void)reverseCopyWithFloatArray:(IOSFloatArray *)coords {
  IOSFloatArray *temp = [IOSFloatArray arrayWithLength:(int) [((IOSFloatArray *) nil_chk(coords)) count]];
  [JavaLangSystem arraycopyWithId:coords withInt:0 withId:temp withInt:0 withInt:(int) [((IOSFloatArray *) nil_chk(coords)) count]];
  for (int i = 0; i < (int) [((IOSFloatArray *) nil_chk(coords)) count]; ) {
    (*[((IOSFloatArray *) nil_chk(coords)) floatRefAtIndex:i]) = [((IOSFloatArray *) nil_chk(temp)) floatAtIndex:(int) [((IOSFloatArray *) nil_chk(coords)) count] - i - 2];
    (*[((IOSFloatArray *) nil_chk(coords)) floatRefAtIndex:i + 1]) = [((IOSFloatArray *) nil_chk(temp)) floatAtIndex:(int) [((IOSFloatArray *) nil_chk(coords)) count] - i - 1];
    i = i + 2;
  }
}

- (float)areaBoundsSquare {
  PythagorasFRectangle *bounds = [self bounds];
  return [((PythagorasFRectangle *) nil_chk(bounds)) height] * [((PythagorasFRectangle *) nil_chk(bounds)) width];
}

- (BOOL)isVertexWithFloat:(float)x
                withFloat:(float)y {
  for (int i = 0; i < coordsSize_; ) {
    if (x == [((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:i++] && y == [((IOSFloatArray *) nil_chk(coords_)) floatAtIndex:i++]) {
      return YES;
    }
  }
  return NO;
}

+ (IOSFloatArray *)adjustSizeWithFloatArray:(IOSFloatArray *)array
                                    withInt:(int)newSize {
  if (newSize <= (int) [((IOSFloatArray *) nil_chk(array)) count]) {
    return array;
  }
  IOSFloatArray *newArray = [IOSFloatArray arrayWithLength:2 * newSize];
  [JavaLangSystem arraycopyWithId:array withInt:0 withId:newArray withInt:0 withInt:(int) [((IOSFloatArray *) nil_chk(array)) count]];
  return newArray;
}

+ (IOSIntArray *)adjustSizeWithIntArray:(IOSIntArray *)array
                                withInt:(int)newSize {
  if (newSize <= (int) [((IOSIntArray *) nil_chk(array)) count]) {
    return array;
  }
  IOSIntArray *newArray = [IOSIntArray arrayWithLength:2 * newSize];
  [JavaLangSystem arraycopyWithId:array withInt:0 withId:newArray withInt:0 withInt:(int) [((IOSIntArray *) nil_chk(array)) count]];
  return newArray;
}

- (id)copyWithZone:(NSZone *)zone {
  return [self clone];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  PythagorasFArea *typedCopy = (PythagorasFArea *) copy;
  typedCopy.coords = coords_;
  typedCopy.coordsSize = coordsSize_;
  typedCopy.rules = rules_;
  typedCopy.rulesSize = rulesSize_;
  typedCopy.offsets = offsets_;
  typedCopy.moveToCount = moveToCount_;
  typedCopy.isPolygonal_ = isPolygonal__;
}

@end
@implementation PythagorasFArea_AreaPathIterator

@synthesize this$0 = this$0_;
@synthesize transform = transform_;
@synthesize curRuleIndex = curRuleIndex_;
@synthesize curCoordIndex = curCoordIndex_;

- (id)initWithPythagorasFArea:(PythagorasFArea *)outer$
     withPythagorasFTransform:(id<PythagorasFTransform>)t {
  if ((self = [super init])) {
    this$0_ = outer$;
    curRuleIndex_ = 0;
    curCoordIndex_ = 0;
    self.transform = t;
  }
  return self;
}

- (int)windingRule {
  return PythagorasFPathIterator_WIND_EVEN_ODD;
}

- (BOOL)isDone {
  return curRuleIndex_ >= this$0_.rulesSize;
}

- (void)next {
  switch ([((IOSIntArray *) nil_chk(this$0_.rules)) intAtIndex:curRuleIndex_]) {
    case PythagorasFPathIterator_SEG_MOVETO:
    case PythagorasFPathIterator_SEG_LINETO:
    curCoordIndex_ += 2;
    break;
    case PythagorasFPathIterator_SEG_QUADTO:
    curCoordIndex_ += 4;
    break;
    case PythagorasFPathIterator_SEG_CUBICTO:
    curCoordIndex_ += 6;
    break;
  }
  curRuleIndex_++;
}

- (int)currentSegmentWithFloatArray:(IOSFloatArray *)c {
  if ([self isDone]) {
    @throw [[JavaUtilNoSuchElementException alloc] initWithNSString:@"Iterator out of bounds"];
  }
  int count = 0;
  switch ([((IOSIntArray *) nil_chk(this$0_.rules)) intAtIndex:curRuleIndex_]) {
    case PythagorasFPathIterator_SEG_CUBICTO:
    (*[((IOSFloatArray *) nil_chk(c)) floatRefAtIndex:4]) = [((IOSFloatArray *) nil_chk(this$0_.coords)) floatAtIndex:curCoordIndex_ + 4];
    (*[((IOSFloatArray *) nil_chk(c)) floatRefAtIndex:5]) = [((IOSFloatArray *) nil_chk(this$0_.coords)) floatAtIndex:curCoordIndex_ + 5];
    count = 1;
    case PythagorasFPathIterator_SEG_QUADTO:
    (*[((IOSFloatArray *) nil_chk(c)) floatRefAtIndex:2]) = [((IOSFloatArray *) nil_chk(this$0_.coords)) floatAtIndex:curCoordIndex_ + 2];
    (*[((IOSFloatArray *) nil_chk(c)) floatRefAtIndex:3]) = [((IOSFloatArray *) nil_chk(this$0_.coords)) floatAtIndex:curCoordIndex_ + 3];
    count += 1;
    case PythagorasFPathIterator_SEG_MOVETO:
    case PythagorasFPathIterator_SEG_LINETO:
    (*[((IOSFloatArray *) nil_chk(c)) floatRefAtIndex:0]) = [((IOSFloatArray *) nil_chk(this$0_.coords)) floatAtIndex:curCoordIndex_];
    (*[((IOSFloatArray *) nil_chk(c)) floatRefAtIndex:1]) = [((IOSFloatArray *) nil_chk(this$0_.coords)) floatAtIndex:curCoordIndex_ + 1];
    count += 1;
  }
  if (transform_ != nil) {
    [transform_ transformWithFloatArray:c withInt:0 withFloatArray:c withInt:0 withInt:count];
  }
  return [((IOSIntArray *) nil_chk(this$0_.rules)) intAtIndex:curRuleIndex_];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  PythagorasFArea_AreaPathIterator *typedCopy = (PythagorasFArea_AreaPathIterator *) copy;
  typedCopy.this$0 = this$0_;
  typedCopy.transform = transform_;
  typedCopy.curRuleIndex = curRuleIndex_;
  typedCopy.curCoordIndex = curCoordIndex_;
}

@end
