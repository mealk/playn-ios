//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: pythagoras/f/Path.java
//
//  Created by Thomas on 7/10/13.
//

#import "IOSByteArray.h"
#import "IOSClass.h"
#import "IOSFloatArray.h"
#import "IOSIntArray.h"
#import "java/lang/IllegalArgumentException.h"
#import "java/lang/Math.h"
#import "java/lang/System.h"
#import "java/util/NoSuchElementException.h"
#import "pythagoras/f/Crossing.h"
#import "pythagoras/f/FlatteningPathIterator.h"
#import "pythagoras/f/IPoint.h"
#import "pythagoras/f/IRectangle.h"
#import "pythagoras/f/IShape.h"
#import "pythagoras/f/IllegalPathStateException.h"
#import "pythagoras/f/Path.h"
#import "pythagoras/f/PathIterator.h"
#import "pythagoras/f/Point.h"
#import "pythagoras/f/Rectangle.h"
#import "pythagoras/f/Transform.h"
#import "pythagoras/util/Platform.h"

@implementation PythagorasFPath

static IOSIntArray * PythagorasFPath_pointShift_;

@synthesize types = types_;
@synthesize points = points_;
@synthesize typeSize = typeSize_;
@synthesize pointSize = pointSize_;
@synthesize rule = rule_;

+ (int)WIND_EVEN_ODD {
  return PythagorasFPath_WIND_EVEN_ODD;
}

+ (int)WIND_NON_ZERO {
  return PythagorasFPath_WIND_NON_ZERO;
}

+ (IOSIntArray *)pointShift {
  return PythagorasFPath_pointShift_;
}

+ (void)setPointShift:(IOSIntArray *)pointShift {
  PythagorasFPath_pointShift_ = pointShift;
}

+ (int)BUFFER_SIZE {
  return PythagorasFPath_BUFFER_SIZE;
}

+ (int)BUFFER_CAPACITY {
  return PythagorasFPath_BUFFER_CAPACITY;
}

- (id)init {
  return [self initPythagorasFPathWithInt:PythagorasFPath_WIND_NON_ZERO withInt:PythagorasFPath_BUFFER_SIZE];
}

- (id)initWithInt:(int)rule {
  return [self initPythagorasFPathWithInt:rule withInt:PythagorasFPath_BUFFER_SIZE];
}

- (id)initPythagorasFPathWithInt:(int)rule
                         withInt:(int)initialCapacity {
  if ((self = [super init])) {
    [self setWindingRuleWithInt:rule];
    types_ = [[IOSByteArray alloc] initWithLength:initialCapacity];
    points_ = [[IOSFloatArray alloc] initWithLength:initialCapacity * 2];
  }
  return self;
}

- (id)initWithInt:(int)rule
          withInt:(int)initialCapacity {
  return [self initPythagorasFPathWithInt:rule withInt:initialCapacity];
}

- (id)initWithPythagorasFIShape:(id<PythagorasFIShape>)shape {
  if ((self = [self initPythagorasFPathWithInt:PythagorasFPath_WIND_NON_ZERO withInt:PythagorasFPath_BUFFER_SIZE])) {
    id<PythagorasFPathIterator> p = [((id<PythagorasFIShape>) NIL_CHK(shape)) pathIteratorWithPythagorasFTransform:nil];
    [self setWindingRuleWithInt:[((id<PythagorasFPathIterator>) NIL_CHK(p)) windingRule]];
    [self appendWithPythagorasFPathIterator:p withBOOL:NO];
  }
  return self;
}

- (void)setWindingRuleWithInt:(int)rule {
  if (rule != PythagorasFPath_WIND_EVEN_ODD && rule != PythagorasFPath_WIND_NON_ZERO) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:@"Invalid winding rule value"];
  }
  self.rule = rule;
}

- (int)windingRule {
  return rule_;
}

- (void)moveToWithFloat:(float)x
              withFloat:(float)y {
  if (typeSize_ > 0 && [((IOSByteArray *) NIL_CHK(types_)) byteAtIndex:typeSize_ - 1] == PythagorasFPathIterator_SEG_MOVETO) {
    [((IOSFloatArray *) NIL_CHK(points_)) replaceFloatAtIndex:pointSize_ - 2 withFloat:x];
    [((IOSFloatArray *) NIL_CHK(points_)) replaceFloatAtIndex:pointSize_ - 1 withFloat:y];
  }
  else {
    [self checkBufWithInt:2 withBOOL:NO];
    [((IOSByteArray *) NIL_CHK(types_)) replaceByteAtIndex:typeSize_++ withByte:PythagorasFPathIterator_SEG_MOVETO];
    [((IOSFloatArray *) NIL_CHK(points_)) replaceFloatAtIndex:pointSize_++ withFloat:x];
    [((IOSFloatArray *) NIL_CHK(points_)) replaceFloatAtIndex:pointSize_++ withFloat:y];
  }
}

- (void)lineToWithFloat:(float)x
              withFloat:(float)y {
  [self checkBufWithInt:2 withBOOL:YES];
  [((IOSByteArray *) NIL_CHK(types_)) replaceByteAtIndex:typeSize_++ withByte:PythagorasFPathIterator_SEG_LINETO];
  [((IOSFloatArray *) NIL_CHK(points_)) replaceFloatAtIndex:pointSize_++ withFloat:x];
  [((IOSFloatArray *) NIL_CHK(points_)) replaceFloatAtIndex:pointSize_++ withFloat:y];
}

- (void)quadToWithFloat:(float)x1
              withFloat:(float)y1
              withFloat:(float)x2
              withFloat:(float)y2 {
  [self checkBufWithInt:4 withBOOL:YES];
  [((IOSByteArray *) NIL_CHK(types_)) replaceByteAtIndex:typeSize_++ withByte:PythagorasFPathIterator_SEG_QUADTO];
  [((IOSFloatArray *) NIL_CHK(points_)) replaceFloatAtIndex:pointSize_++ withFloat:x1];
  [((IOSFloatArray *) NIL_CHK(points_)) replaceFloatAtIndex:pointSize_++ withFloat:y1];
  [((IOSFloatArray *) NIL_CHK(points_)) replaceFloatAtIndex:pointSize_++ withFloat:x2];
  [((IOSFloatArray *) NIL_CHK(points_)) replaceFloatAtIndex:pointSize_++ withFloat:y2];
}

- (void)curveToWithFloat:(float)x1
               withFloat:(float)y1
               withFloat:(float)x2
               withFloat:(float)y2
               withFloat:(float)x3
               withFloat:(float)y3 {
  [self checkBufWithInt:6 withBOOL:YES];
  [((IOSByteArray *) NIL_CHK(types_)) replaceByteAtIndex:typeSize_++ withByte:PythagorasFPathIterator_SEG_CUBICTO];
  [((IOSFloatArray *) NIL_CHK(points_)) replaceFloatAtIndex:pointSize_++ withFloat:x1];
  [((IOSFloatArray *) NIL_CHK(points_)) replaceFloatAtIndex:pointSize_++ withFloat:y1];
  [((IOSFloatArray *) NIL_CHK(points_)) replaceFloatAtIndex:pointSize_++ withFloat:x2];
  [((IOSFloatArray *) NIL_CHK(points_)) replaceFloatAtIndex:pointSize_++ withFloat:y2];
  [((IOSFloatArray *) NIL_CHK(points_)) replaceFloatAtIndex:pointSize_++ withFloat:x3];
  [((IOSFloatArray *) NIL_CHK(points_)) replaceFloatAtIndex:pointSize_++ withFloat:y3];
}

- (void)closePath {
  if (typeSize_ == 0 || [((IOSByteArray *) NIL_CHK(types_)) byteAtIndex:typeSize_ - 1] != PythagorasFPathIterator_SEG_CLOSE) {
    [self checkBufWithInt:0 withBOOL:YES];
    [((IOSByteArray *) NIL_CHK(types_)) replaceByteAtIndex:typeSize_++ withByte:PythagorasFPathIterator_SEG_CLOSE];
  }
}

- (void)appendWithPythagorasFIShape:(id<PythagorasFIShape>)shape
                           withBOOL:(BOOL)connect {
  id<PythagorasFPathIterator> p = [((id<PythagorasFIShape>) NIL_CHK(shape)) pathIteratorWithPythagorasFTransform:nil];
  [self appendWithPythagorasFPathIterator:p withBOOL:connect];
}

- (void)appendWithPythagorasFPathIterator:(id<PythagorasFPathIterator>)path
                                 withBOOL:(BOOL)connect {
  while (![((id<PythagorasFPathIterator>) NIL_CHK(path)) isDone]) {
    IOSFloatArray *coords = [[IOSFloatArray alloc] initWithLength:6];
    switch ([((id<PythagorasFPathIterator>) NIL_CHK(path)) currentSegmentWithJavaLangFloatArray:coords]) {
      case PythagorasFPathIterator_SEG_MOVETO:
      if (!connect || typeSize_ == 0) {
        [self moveToWithFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:1]];
      }
      else if ([((IOSByteArray *) NIL_CHK(types_)) byteAtIndex:typeSize_ - 1] != PythagorasFPathIterator_SEG_CLOSE && [((IOSFloatArray *) NIL_CHK(points_)) floatAtIndex:pointSize_ - 2] == [((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:0] && [((IOSFloatArray *) NIL_CHK(points_)) floatAtIndex:pointSize_ - 1] == [((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:1]) {
      }
      else {
        [self lineToWithFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:1]];
      }
      break;
      case PythagorasFPathIterator_SEG_LINETO:
      [self lineToWithFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:1]];
      break;
      case PythagorasFPathIterator_SEG_QUADTO:
      [self quadToWithFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:3]];
      break;
      case PythagorasFPathIterator_SEG_CUBICTO:
      [self curveToWithFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:4] withFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:5]];
      break;
      case PythagorasFPathIterator_SEG_CLOSE:
      [self closePath];
      break;
    }
    [((id<PythagorasFPathIterator>) NIL_CHK(path)) next];
    connect = NO;
  }
}

- (PythagorasFPoint *)currentPoint {
  if (typeSize_ == 0) {
    return nil;
  }
  int j = pointSize_ - 2;
  if ([((IOSByteArray *) NIL_CHK(types_)) byteAtIndex:typeSize_ - 1] == PythagorasFPathIterator_SEG_CLOSE) {
    for (int i = typeSize_ - 2; i > 0; i--) {
      int type = [((IOSByteArray *) NIL_CHK(types_)) byteAtIndex:i];
      if (type == PythagorasFPathIterator_SEG_MOVETO) {
        break;
      }
      j -= [((IOSIntArray *) NIL_CHK(PythagorasFPath_pointShift_)) intAtIndex:type];
    }
  }
  return [[PythagorasFPoint alloc] initWithFloat:[((IOSFloatArray *) NIL_CHK(points_)) floatAtIndex:j] withFloat:[((IOSFloatArray *) NIL_CHK(points_)) floatAtIndex:j + 1]];
}

- (void)reset {
  typeSize_ = 0;
  pointSize_ = 0;
}

- (void)transformWithPythagorasFTransform:(id<PythagorasFTransform>)t {
  [((id<PythagorasFTransform>) NIL_CHK(t)) transformWithJavaLangFloatArray:points_ withInt:0 withJavaLangFloatArray:points_ withInt:0 withInt:pointSize_ / 2];
}

- (id<PythagorasFIShape>)createTransformedShapeWithPythagorasFTransform:(id<PythagorasFTransform>)t {
  PythagorasFPath *p = [self clone];
  if (t != nil) {
    [((PythagorasFPath *) NIL_CHK(p)) transformWithPythagorasFTransform:t];
  }
  return p;
}

- (PythagorasFRectangle *)bounds {
  return [self boundsWithPythagorasFRectangle:[[PythagorasFRectangle alloc] init]];
}

- (PythagorasFRectangle *)boundsWithPythagorasFRectangle:(PythagorasFRectangle *)target {
  float rx1, ry1, rx2, ry2;
  if (pointSize_ == 0) {
    rx1 = ry1 = rx2 = ry2 = 0.0f;
  }
  else {
    int i = pointSize_ - 1;
    ry1 = ry2 = [((IOSFloatArray *) NIL_CHK(points_)) floatAtIndex:i--];
    rx1 = rx2 = [((IOSFloatArray *) NIL_CHK(points_)) floatAtIndex:i--];
    while (i > 0) {
      float y = [((IOSFloatArray *) NIL_CHK(points_)) floatAtIndex:i--];
      float x = [((IOSFloatArray *) NIL_CHK(points_)) floatAtIndex:i--];
      if (x < rx1) {
        rx1 = x;
      }
      else if (x > rx2) {
        rx2 = x;
      }
      if (y < ry1) {
        ry1 = y;
      }
      else if (y > ry2) {
        ry2 = y;
      }
    }
  }
  [((PythagorasFRectangle *) NIL_CHK(target)) setBoundsWithFloat:rx1 withFloat:ry1 withFloat:rx2 - rx1 withFloat:ry2 - ry1];
  return target;
}

- (BOOL)isEmpty {
  return [[self bounds] isEmpty];
}

- (BOOL)containsWithFloat:(float)px
                withFloat:(float)py {
  return [self isInsideWithInt:[PythagorasFCrossing crossShapeWithPythagorasFIShape:self withFloat:px withFloat:py]];
}

- (BOOL)containsWithFloat:(float)rx
                withFloat:(float)ry
                withFloat:(float)rw
                withFloat:(float)rh {
  int cross = [PythagorasFCrossing intersectShapeWithPythagorasFIShape:self withFloat:rx withFloat:ry withFloat:rw withFloat:rh];
  return cross != PythagorasFCrossing_CROSSING && [self isInsideWithInt:cross];
}

- (BOOL)intersectsWithFloat:(float)rx
                  withFloat:(float)ry
                  withFloat:(float)rw
                  withFloat:(float)rh {
  int cross = [PythagorasFCrossing intersectShapeWithPythagorasFIShape:self withFloat:rx withFloat:ry withFloat:rw withFloat:rh];
  return cross == PythagorasFCrossing_CROSSING || [self isInsideWithInt:cross];
}

- (BOOL)containsWithPythagorasFIPoint:(id<PythagorasFIPoint>)p {
  return [self containsWithFloat:[((id<PythagorasFIPoint>) NIL_CHK(p)) x] withFloat:[((id<PythagorasFIPoint>) NIL_CHK(p)) y]];
}

- (BOOL)containsWithPythagorasFIRectangle:(id<PythagorasFIRectangle>)r {
  return [self containsWithFloat:[((id<PythagorasFIRectangle>) NIL_CHK(r)) x] withFloat:[((id<PythagorasFIRectangle>) NIL_CHK(r)) y] withFloat:[((id<PythagorasFIRectangle>) NIL_CHK(r)) width] withFloat:[((id<PythagorasFIRectangle>) NIL_CHK(r)) height]];
}

- (BOOL)intersectsWithPythagorasFIRectangle:(id<PythagorasFIRectangle>)r {
  return [self intersectsWithFloat:[((id<PythagorasFIRectangle>) NIL_CHK(r)) x] withFloat:[((id<PythagorasFIRectangle>) NIL_CHK(r)) y] withFloat:[((id<PythagorasFIRectangle>) NIL_CHK(r)) width] withFloat:[((id<PythagorasFIRectangle>) NIL_CHK(r)) height]];
}

- (id<PythagorasFPathIterator>)pathIteratorWithPythagorasFTransform:(id<PythagorasFTransform>)t {
  return [[PythagorasFPath_Iterator alloc] initWithPythagorasFPath:self withPythagorasFTransform:t];
}

- (id<PythagorasFPathIterator>)pathIteratorWithPythagorasFTransform:(id<PythagorasFTransform>)t
                                                          withFloat:(float)flatness {
  return [[PythagorasFFlatteningPathIterator alloc] initWithPythagorasFPathIterator:[self pathIteratorWithPythagorasFTransform:t] withFloat:flatness];
}

- (PythagorasFPath *)clone {
  return [[PythagorasFPath alloc] initWithInt:rule_ withJavaLangByteArray:[PythagorasUtilPlatform cloneWithJavaLangByteArray:types_] withJavaLangFloatArray:[PythagorasUtilPlatform cloneWithJavaLangFloatArray:points_] withInt:typeSize_ withInt:pointSize_];
}

- (void)checkBufWithInt:(int)pointCount
               withBOOL:(BOOL)checkMove {
  if (checkMove && typeSize_ == 0) {
    @throw [[PythagorasFIllegalPathStateException alloc] initWithNSString:@"First segment must be a SEG_MOVETO"];
  }
  if (typeSize_ == (int) [((IOSByteArray *) NIL_CHK(types_)) count]) {
    IOSByteArray *tmp = [[IOSByteArray alloc] initWithLength:typeSize_ + PythagorasFPath_BUFFER_CAPACITY];
    [JavaLangSystem arraycopyWithId:types_ withInt:0 withId:tmp withInt:0 withInt:typeSize_];
    types_ = tmp;
  }
  if (pointSize_ + pointCount > (int) [((IOSFloatArray *) NIL_CHK(points_)) count]) {
    IOSFloatArray *tmp = [[IOSFloatArray alloc] initWithLength:pointSize_ + [JavaLangMath maxWithInt:PythagorasFPath_BUFFER_CAPACITY * 2 withInt:pointCount]];
    [JavaLangSystem arraycopyWithId:points_ withInt:0 withId:tmp withInt:0 withInt:pointSize_];
    points_ = tmp;
  }
}

- (BOOL)isInsideWithInt:(int)cross {
  return (rule_ == PythagorasFPath_WIND_NON_ZERO) ? [PythagorasFCrossing isInsideNonZeroWithInt:cross] : [PythagorasFCrossing isInsideEvenOddWithInt:cross];
}

- (id)initWithInt:(int)rule
withJavaLangByteArray:(IOSByteArray *)types
withJavaLangFloatArray:(IOSFloatArray *)points
          withInt:(int)typeSize
          withInt:(int)pointSize {
  if ((self = [super init])) {
    self.rule = rule;
    self.types = types;
    self.points = points;
    self.typeSize = typeSize;
    self.pointSize = pointSize;
  }
  return self;
}

+ (void)initialize {
  if (self == [PythagorasFPath class]) {
    PythagorasFPath_pointShift_ = [IOSIntArray arrayWithInts:(int[]){ 2, 2, 4, 6, 0 } count:5];
  }
}

- (id)copyWithZone:(NSZone *)zone {
  return [self clone];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  PythagorasFPath *typedCopy = (PythagorasFPath *) copy;
  typedCopy.types = types_;
  typedCopy.points = points_;
  typedCopy.typeSize = typeSize_;
  typedCopy.pointSize = pointSize_;
  typedCopy.rule = rule_;
}

@end
@implementation PythagorasFPath_Iterator

@synthesize typeIndex = typeIndex_;
@synthesize pointIndex = pointIndex_;
@synthesize p = p_;
@synthesize t = t_;

- (id)initWithPythagorasFPath:(PythagorasFPath *)path {
  return [self initPythagorasFPath_IteratorWithPythagorasFPath:path withPythagorasFTransform:nil];
}

- (id)initPythagorasFPath_IteratorWithPythagorasFPath:(PythagorasFPath *)path
                             withPythagorasFTransform:(id<PythagorasFTransform>)at {
  if ((self = [super init])) {
    self.p = path;
    self.t = at;
  }
  return self;
}

- (id)initWithPythagorasFPath:(PythagorasFPath *)path
     withPythagorasFTransform:(id<PythagorasFTransform>)at {
  return [self initPythagorasFPath_IteratorWithPythagorasFPath:path withPythagorasFTransform:at];
}

- (int)windingRule {
  return [((PythagorasFPath *) NIL_CHK(p_)) windingRule];
}

- (BOOL)isDone {
  return typeIndex_ >= ((PythagorasFPath *) NIL_CHK(p_)).typeSize;
}

- (void)next {
  typeIndex_++;
}

- (int)currentSegmentWithJavaLangFloatArray:(IOSFloatArray *)coords {
  if ([self isDone]) {
    @throw [[JavaUtilNoSuchElementException alloc] initWithNSString:@"Iterator out of bounds"];
  }
  int type = [((IOSByteArray *) NIL_CHK(p_.types)) byteAtIndex:typeIndex_];
  int count = [((IOSIntArray *) NIL_CHK([PythagorasFPath pointShift])) intAtIndex:type];
  [JavaLangSystem arraycopyWithId:((PythagorasFPath *) NIL_CHK(p_)).points withInt:pointIndex_ withId:coords withInt:0 withInt:count];
  if (t_ != nil) {
    [t_ transformWithJavaLangFloatArray:coords withInt:0 withJavaLangFloatArray:coords withInt:0 withInt:count / 2];
  }
  pointIndex_ += count;
  return type;
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  PythagorasFPath_Iterator *typedCopy = (PythagorasFPath_Iterator *) copy;
  typedCopy.typeIndex = typeIndex_;
  typedCopy.pointIndex = pointIndex_;
  typedCopy.p = p_;
  typedCopy.t = t_;
}

@end
