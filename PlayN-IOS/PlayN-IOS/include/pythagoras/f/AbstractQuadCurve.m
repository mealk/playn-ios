//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: pythagoras/f/AbstractQuadCurve.java
//
//  Created by Thomas on 7/25/13.
//

#include "IOSFloatArray.h"
#include "java/lang/Math.h"
#include "java/util/NoSuchElementException.h"
#include "pythagoras/f/AbstractQuadCurve.h"
#include "pythagoras/f/Crossing.h"
#include "pythagoras/f/FlatteningPathIterator.h"
#include "pythagoras/f/IPoint.h"
#include "pythagoras/f/IQuadCurve.h"
#include "pythagoras/f/IRectangle.h"
#include "pythagoras/f/Lines.h"
#include "pythagoras/f/PathIterator.h"
#include "pythagoras/f/Point.h"
#include "pythagoras/f/QuadCurve.h"
#include "pythagoras/f/QuadCurves.h"
#include "pythagoras/f/Rectangle.h"
#include "pythagoras/f/Transform.h"

@implementation PythagorasFAbstractQuadCurve

- (PythagorasFPoint *)p1 {
  return [[PythagorasFPoint alloc] initWithFloat:[self x1] withFloat:[self y1]];
}

- (PythagorasFPoint *)ctrlP {
  return [[PythagorasFPoint alloc] initWithFloat:[self ctrlX] withFloat:[self ctrlY]];
}

- (PythagorasFPoint *)p2 {
  return [[PythagorasFPoint alloc] initWithFloat:[self x2] withFloat:[self y2]];
}

- (float)flatnessSq {
  return [PythagorasFLines pointSegDistSqWithFloat:[self ctrlX] withFloat:[self ctrlY] withFloat:[self x1] withFloat:[self y1] withFloat:[self x2] withFloat:[self y2]];
}

- (float)flatness {
  return [PythagorasFLines pointSegDistWithFloat:[self ctrlX] withFloat:[self ctrlY] withFloat:[self x1] withFloat:[self y1] withFloat:[self x2] withFloat:[self y2]];
}

- (void)subdivideWithPythagorasFQuadCurve:(PythagorasFQuadCurve *)left
                 withPythagorasFQuadCurve:(PythagorasFQuadCurve *)right {
  [PythagorasFQuadCurves subdivideWithPythagorasFIQuadCurve:self withPythagorasFQuadCurve:left withPythagorasFQuadCurve:right];
}

- (PythagorasFQuadCurve *)clone {
  return [[PythagorasFQuadCurve alloc] initWithFloat:[self x1] withFloat:[self y1] withFloat:[self ctrlX] withFloat:[self ctrlY] withFloat:[self x2] withFloat:[self y2]];
}

- (BOOL)isEmpty {
  return YES;
}

- (BOOL)containsWithFloat:(float)px
                withFloat:(float)py {
  return [PythagorasFCrossing isInsideEvenOddWithInt:[PythagorasFCrossing crossShapeWithPythagorasFIShape:self withFloat:px withFloat:py]];
}

- (BOOL)containsWithFloat:(float)rx
                withFloat:(float)ry
                withFloat:(float)rw
                withFloat:(float)rh {
  int cross = [PythagorasFCrossing intersectShapeWithPythagorasFIShape:self withFloat:rx withFloat:ry withFloat:rw withFloat:rh];
  return cross != PythagorasFCrossing_CROSSING && [PythagorasFCrossing isInsideEvenOddWithInt:cross];
}

- (BOOL)containsWithPythagorasFIPoint:(id<PythagorasFIPoint>)p {
  return [self containsWithFloat:[((id<PythagorasFIPoint>) nil_chk(p)) x] withFloat:[((id<PythagorasFIPoint>) nil_chk(p)) y]];
}

- (BOOL)containsWithPythagorasFIRectangle:(id<PythagorasFIRectangle>)r {
  return [self containsWithFloat:[((id<PythagorasFIRectangle>) nil_chk(r)) x] withFloat:[((id<PythagorasFIRectangle>) nil_chk(r)) y] withFloat:[((id<PythagorasFIRectangle>) nil_chk(r)) width] withFloat:[((id<PythagorasFIRectangle>) nil_chk(r)) height]];
}

- (BOOL)intersectsWithFloat:(float)rx
                  withFloat:(float)ry
                  withFloat:(float)rw
                  withFloat:(float)rh {
  int cross = [PythagorasFCrossing intersectShapeWithPythagorasFIShape:self withFloat:rx withFloat:ry withFloat:rw withFloat:rh];
  return cross == PythagorasFCrossing_CROSSING || [PythagorasFCrossing isInsideEvenOddWithInt:cross];
}

- (BOOL)intersectsWithPythagorasFIRectangle:(id<PythagorasFIRectangle>)r {
  return [self intersectsWithFloat:[((id<PythagorasFIRectangle>) nil_chk(r)) x] withFloat:[((id<PythagorasFIRectangle>) nil_chk(r)) y] withFloat:[((id<PythagorasFIRectangle>) nil_chk(r)) width] withFloat:[((id<PythagorasFIRectangle>) nil_chk(r)) height]];
}

- (PythagorasFRectangle *)bounds {
  return [self boundsWithPythagorasFRectangle:[[PythagorasFRectangle alloc] init]];
}

- (PythagorasFRectangle *)boundsWithPythagorasFRectangle:(PythagorasFRectangle *)target {
  float x1 = [self x1], y1 = [self y1], x2 = [self x2], y2 = [self y2];
  float ctrlx = [self ctrlX], ctrly = [self ctrlY];
  float rx0 = [JavaLangMath minWithFloat:[JavaLangMath minWithFloat:x1 withFloat:x2] withFloat:ctrlx];
  float ry0 = [JavaLangMath minWithFloat:[JavaLangMath minWithFloat:y1 withFloat:y2] withFloat:ctrly];
  float rx1 = [JavaLangMath maxWithFloat:[JavaLangMath maxWithFloat:x1 withFloat:x2] withFloat:ctrlx];
  float ry1 = [JavaLangMath maxWithFloat:[JavaLangMath maxWithFloat:y1 withFloat:y2] withFloat:ctrly];
  [((PythagorasFRectangle *) nil_chk(target)) setBoundsWithFloat:rx0 withFloat:ry0 withFloat:rx1 - rx0 withFloat:ry1 - ry0];
  return target;
}

- (id<PythagorasFPathIterator>)pathIteratorWithPythagorasFTransform:(id<PythagorasFTransform>)t {
  return [[PythagorasFAbstractQuadCurve_Iterator alloc] initWithPythagorasFIQuadCurve:self withPythagorasFTransform:t];
}

- (id<PythagorasFPathIterator>)pathIteratorWithPythagorasFTransform:(id<PythagorasFTransform>)t
                                                          withFloat:(float)flatness {
  return [[PythagorasFFlatteningPathIterator alloc] initWithPythagorasFPathIterator:[self pathIteratorWithPythagorasFTransform:t] withFloat:flatness];
}

- (float)ctrlX {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (float)ctrlY {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (float)x1 {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (float)x2 {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (float)y1 {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (float)y2 {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)init {
  return [super init];
}

- (id)copyWithZone:(NSZone *)zone {
  return [self clone];
}

@end
@implementation PythagorasFAbstractQuadCurve_Iterator

@synthesize c = c_;
@synthesize t = t_;
@synthesize index = index_;

- (id)initWithPythagorasFIQuadCurve:(id<PythagorasFIQuadCurve>)q
           withPythagorasFTransform:(id<PythagorasFTransform>)t {
  if ((self = [super init])) {
    self.c = q;
    self.t = t;
  }
  return self;
}

- (int)windingRule {
  return PythagorasFPathIterator_WIND_NON_ZERO;
}

- (BOOL)isDone {
  return (index_ > 1);
}

- (void)next {
  index_++;
}

- (int)currentSegmentWithFloatArray:(IOSFloatArray *)coords {
  if ([self isDone]) {
    @throw [[JavaUtilNoSuchElementException alloc] initWithNSString:@"Iterator out of bounds"];
  }
  int type;
  int count;
  if (index_ == 0) {
    type = PythagorasFPathIterator_SEG_MOVETO;
    (*[((IOSFloatArray *) nil_chk(coords)) floatRefAtIndex:0]) = [((id<PythagorasFIQuadCurve>) nil_chk(c_)) x1];
    (*[((IOSFloatArray *) nil_chk(coords)) floatRefAtIndex:1]) = [((id<PythagorasFIQuadCurve>) nil_chk(c_)) y1];
    count = 1;
  }
  else {
    type = PythagorasFPathIterator_SEG_QUADTO;
    (*[((IOSFloatArray *) nil_chk(coords)) floatRefAtIndex:0]) = [((id<PythagorasFIQuadCurve>) nil_chk(c_)) ctrlX];
    (*[((IOSFloatArray *) nil_chk(coords)) floatRefAtIndex:1]) = [((id<PythagorasFIQuadCurve>) nil_chk(c_)) ctrlY];
    (*[((IOSFloatArray *) nil_chk(coords)) floatRefAtIndex:2]) = [((id<PythagorasFIQuadCurve>) nil_chk(c_)) x2];
    (*[((IOSFloatArray *) nil_chk(coords)) floatRefAtIndex:3]) = [((id<PythagorasFIQuadCurve>) nil_chk(c_)) y2];
    count = 2;
  }
  if (t_ != nil) {
    [t_ transformWithFloatArray:coords withInt:0 withFloatArray:coords withInt:0 withInt:count];
  }
  return type;
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  PythagorasFAbstractQuadCurve_Iterator *typedCopy = (PythagorasFAbstractQuadCurve_Iterator *) copy;
  typedCopy.c = c_;
  typedCopy.t = t_;
  typedCopy.index = index_;
}

@end
