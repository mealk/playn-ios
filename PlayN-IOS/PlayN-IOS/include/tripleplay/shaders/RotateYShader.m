//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: tripleplay/shaders/RotateYShader.java
//
//  Created by Thomas on 7/10/13.
//

#import "playn/core/gl/GLContext.h"
#import "playn/core/gl/GLProgram.h"
#import "playn/core/gl/GLShader.h"
#import "playn/core/gl/IndexedTrisShader.h"
#import "tripleplay/shaders/RotateYShader.h"
#import "tripleplay/shaders/ShaderUtil.h"

@implementation TripleplayShadersRotateYShader

@synthesize angle = angle_;
@synthesize eyeX = eyeX_;
@synthesize eyeY = eyeY_;
@synthesize zScale = zScale_;

- (id)initWithPlaynCoreGlGLContext:(PlaynCoreGlGLContext *)ctx
                         withFloat:(float)eyeX
                         withFloat:(float)eyeY
                         withFloat:(float)zScale {
  if ((self = [super initWithPlaynCoreGlGLContext:ctx])) {
    self.eyeX = eyeX;
    self.eyeY = eyeY;
    self.zScale = zScale;
  }
  return self;
}

- (NSString *)vertexShader {
  return [NSString stringWithFormat:@"uniform vec2 u_ScreenSize;\nuniform float u_Angle;\nattribute vec4 a_Matrix;\nattribute vec2 a_Translation;\nattribute vec2 a_Position;\nattribute vec2 a_TexCoord;\nattribute vec2 a_Color;\nvarying vec2 v_TexCoord;\nvarying vec4 v_Color;\nvoid main(void) {\n  mat4 transform = mat4(\n    a_Matrix[0],      a_Matrix[1],      0, 0,\n    a_Matrix[2],      a_Matrix[3],      0, 0,\n    0,                0,                1, 0,\n    a_Translation[0], a_Translation[1], 0, 1);\n  vec4 pos = transform * vec4(a_Position, 0, 1);\n  float cosa = cos(u_Angle);\n  float sina = sin(u_Angle);\n  mat4 rotmat = mat4(\n    cosa, 0, sina, 0,\n    0,    1, 0,    0,\n   -sina, 0, cosa, 0,\n    0,    0, 0,    1);\n  pos = rotmat * vec4(pos.x - %@ * u_ScreenSize.x,\n                      pos.y - %@ * u_ScreenSize.y,\n                      0, 1);\n  mat4 persp = mat4(\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, -1.0/2000.0,\n    0, 0, 0, 1);\n  pos = persp * pos;\n  pos += vec4(%@ * u_ScreenSize.x,\n              %@ * u_ScreenSize.y, 0, 0);\n  pos.x /= (u_ScreenSize.x / 2.0);\n  pos.y /= (u_ScreenSize.y / 2.0);\n  pos.z /= (u_ScreenSize.x * %@);\n  pos.x -= 1.0;\n  pos.y = 1.0 - pos.y;\n  gl_Position = pos;\nv_TexCoord = a_TexCoord;\nfloat red = mod(a_Color.x, 256.0);\nfloat alpha = (a_Color.x - red) / 256.0;\nfloat blue = mod(a_Color.y, 256.0);\nfloat green = (a_Color.y - blue) / 256.0;\nv_Color = vec4(red / 255.0, green / 255.0, blue / 255.0, alpha / 255.0);\n}", [TripleplayShadersShaderUtil formatWithFloat:eyeX_], [TripleplayShadersShaderUtil formatWithFloat:eyeY_], [TripleplayShadersShaderUtil formatWithFloat:eyeX_], [TripleplayShadersShaderUtil formatWithFloat:eyeY_], [TripleplayShadersShaderUtil formatWithFloat:zScale_]];
}

- (PlaynCoreGlGLShader_Core *)createTextureCore {
  return [[TripleplayShadersRotateYShader_RotateYCore alloc] initWithTripleplayShadersRotateYShader:self withNSString:[self vertexShader] withNSString:[self textureFragmentShader]];
}

- (PlaynCoreGlGLShader_Core *)createColorCore {
  return [[TripleplayShadersRotateYShader_RotateYCore alloc] initWithTripleplayShadersRotateYShader:self withNSString:[self vertexShader] withNSString:[self colorFragmentShader]];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  TripleplayShadersRotateYShader *typedCopy = (TripleplayShadersRotateYShader *) copy;
  typedCopy.angle = angle_;
  typedCopy.eyeX = eyeX_;
  typedCopy.eyeY = eyeY_;
  typedCopy.zScale = zScale_;
}

@end
@implementation TripleplayShadersRotateYShader_RotateYCore

@synthesize this$2 = this$2_;
@synthesize _uAngle = _uAngle_;

- (id)initWithTripleplayShadersRotateYShader:(TripleplayShadersRotateYShader *)outer$
                                withNSString:(NSString *)vertShader
                                withNSString:(NSString *)fragShader {
  if ((self = [super initWithPlaynCoreGlIndexedTrisShader:outer$ withNSString:vertShader withNSString:fragShader])) {
    this$2_ = outer$;
    _uAngle_ = [((id<PlaynCoreGlGLProgram>) NIL_CHK(prog_)) getUniform1fWithNSString:@"u_Angle"];
  }
  return self;
}

- (void)activateWithInt:(int)fbufWidth
                withInt:(int)fbufHeight {
  [super activateWithInt:fbufWidth withInt:fbufHeight];
  [((id<PlaynCoreGlGLShader_Uniform1f>) NIL_CHK(_uAngle_)) bindWithFloat:this$2_.angle];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  TripleplayShadersRotateYShader_RotateYCore *typedCopy = (TripleplayShadersRotateYShader_RotateYCore *) copy;
  typedCopy.this$2 = this$2_;
  typedCopy._uAngle = _uAngle_;
}

@end
