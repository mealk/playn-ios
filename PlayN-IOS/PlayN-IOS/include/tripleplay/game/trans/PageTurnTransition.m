//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: tripleplay/game/trans/PageTurnTransition.java
//
//  Created by Thomas on 7/25/13.
//

#include "IOSClass.h"
#include "playn/core/Graphics.h"
#include "playn/core/GroupLayer.h"
#include "playn/core/ImmediateLayer.h"
#include "playn/core/Layer.h"
#include "playn/core/PlayN.h"
#include "playn/core/Surface.h"
#include "playn/core/gl/GLContext.h"
#include "pythagoras/f/FloatMath.h"
#include "pythagoras/f/MathUtil.h"
#include "tripleplay/game/Screen.h"
#include "tripleplay/game/trans/PageTurnTransition.h"
#include "tripleplay/shaders/RotateYShader.h"
#include "tripleplay/util/Interpolator.h"

@implementation TripleplayGameTransPageTurnTransition

@synthesize _alpha = _alpha_;
@synthesize _close = _close_;
@synthesize _toflip = _toflip_;
@synthesize _shadow = _shadow_;
@synthesize _shader = _shader_;

- (TripleplayGameTransPageTurnTransition *)close {
  _close_ = YES;
  _interp_ = [TripleplayUtilInterpolator EASE_INOUT];
  return self;
}

- (void)init__WithTripleplayGameScreen:(TripleplayGameScreen *)oscreen
              withTripleplayGameScreen:(TripleplayGameScreen *)nscreen OBJC_METHOD_FAMILY_NONE {
  [super init__WithTripleplayGameScreen:oscreen withTripleplayGameScreen:nscreen];
  (void) [((id<PlaynCoreGroupLayer>) nil_chk(((TripleplayGameScreen *) nil_chk(nscreen)).layer)) setDepthWithFloat:_close_ ? 1 : -1];
  _toflip_ = _close_ ? nscreen : oscreen;
  _shader_ = [[TripleplayShadersRotateYShader alloc] initWithPlaynCoreGlGLContext:[((id<PlaynCoreGraphics>) nil_chk([PlaynCorePlayN graphics])) ctx] withFloat:0.0f withFloat:0.5f withFloat:1.5f];
  (void) [((id<PlaynCoreGroupLayer>) nil_chk(((TripleplayGameScreen *) nil_chk(_toflip_)).layer)) setShaderWithPlaynCoreGlGLShader:_shader_];
  float fwidth = [((TripleplayGameScreen *) nil_chk(_toflip_)) width], fheight = [((TripleplayGameScreen *) nil_chk(_toflip_)) height];
  _shadow_ = [((id<PlaynCoreGraphics>) nil_chk([PlaynCorePlayN graphics])) createImmediateLayerWithPlaynCoreImmediateLayer_Renderer:[[TripleplayGameTransPageTurnTransition_$1 alloc] initWithTripleplayGameTransPageTurnTransition:self withFloat:fwidth withFloat:fheight]];
  [((id<PlaynCoreGroupLayer>) nil_chk(((TripleplayGameScreen *) nil_chk(_toflip_)).layer)) addAtWithPlaynCoreLayer:_shadow_ withFloat:fwidth withFloat:0];
  [self updateAngleWithFloat:0];
}

- (BOOL)updateWithTripleplayGameScreen:(TripleplayGameScreen *)oscreen
              withTripleplayGameScreen:(TripleplayGameScreen *)nscreen
                             withFloat:(float)elapsed {
  [self updateAngleWithFloat:elapsed];
  return elapsed >= _duration_;
}

- (void)completeWithTripleplayGameScreen:(TripleplayGameScreen *)oscreen
                withTripleplayGameScreen:(TripleplayGameScreen *)nscreen {
  [super completeWithTripleplayGameScreen:oscreen withTripleplayGameScreen:nscreen];
  [((id<PlaynCoreImmediateLayer>) nil_chk(_shadow_)) destroy];
  (void) [((id<PlaynCoreGroupLayer>) nil_chk(((TripleplayGameScreen *) nil_chk(nscreen)).layer)) setDepthWithFloat:0];
  (void) [((id<PlaynCoreGroupLayer>) nil_chk(((TripleplayGameScreen *) nil_chk(_toflip_)).layer)) setShaderWithPlaynCoreGlGLShader:nil];
}

- (float)defaultDuration {
  return 1500;
}

- (TripleplayUtilInterpolator *)defaultInterpolator {
  return [TripleplayUtilInterpolator EASE_IN];
}

- (void)updateAngleWithFloat:(float)elapsed {
  float pct = [PythagorasFMathUtil clampWithFloat:[((TripleplayUtilInterpolator *) nil_chk(_interp_)) applyWithFloat:0 withFloat:0.5f withFloat:elapsed withFloat:_duration_] withFloat:0 withFloat:0.5f];
  if (_close_) pct = 0.5f - pct;
  _alpha_ = pct;
  ((TripleplayShadersRotateYShader *) nil_chk(_shader_)).angle = PythagorasFFloatMath_PI * pct;
}

- (id)init {
  return [super init];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  TripleplayGameTransPageTurnTransition *typedCopy = (TripleplayGameTransPageTurnTransition *) copy;
  typedCopy._alpha = _alpha_;
  typedCopy._close = _close_;
  typedCopy._toflip = _toflip_;
  typedCopy._shadow = _shadow_;
  typedCopy._shader = _shader_;
}

@end
@implementation TripleplayGameTransPageTurnTransition_$1

@synthesize this$0 = this$0_;
@synthesize val$fwidth = val$fwidth_;
@synthesize val$fheight = val$fheight_;

- (void)renderWithPlaynCoreSurface:(id<PlaynCoreSurface>)surf {
  (void) [((id<PlaynCoreSurface>) nil_chk(surf)) setAlphaWithFloat:this$0_._alpha];
  (void) [((id<PlaynCoreSurface>) nil_chk(surf)) setFillColorWithInt:(int) 0xFF000000];
  (void) [((id<PlaynCoreSurface>) nil_chk(surf)) fillRectWithFloat:0 withFloat:0 withFloat:val$fwidth_ / 4 withFloat:val$fheight_];
}

- (id)initWithTripleplayGameTransPageTurnTransition:(TripleplayGameTransPageTurnTransition *)outer$
                                          withFloat:(float)capture$0
                                          withFloat:(float)capture$1 {
  if ((self = [super init])) {
    this$0_ = outer$;
    val$fwidth_ = capture$0;
    val$fheight_ = capture$1;
  }
  return self;
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  TripleplayGameTransPageTurnTransition_$1 *typedCopy = (TripleplayGameTransPageTurnTransition_$1 *) copy;
  typedCopy.this$0 = this$0_;
  typedCopy.val$fwidth = val$fwidth_;
  typedCopy.val$fheight = val$fheight_;
}

@end
