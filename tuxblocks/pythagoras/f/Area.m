//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: pythagoras/f/Area.java
//
//  Created by Thomas on 7/1/13.
//

#import "Crossing.h"
#import "CrossingHelper.h"
#import "CurveCrossingHelper.h"
#import "FlatteningPathIterator.h"
#import "GeometryUtil.h"
#import "IOSClass.h"
#import "IOSFloatArray.h"
#import "IOSIntArray.h"
#import "IOSObjectArray.h"
#import "IPoint.h"
#import "IRectangle.h"
#import "IShape.h"
#import "IntersectPoint.h"
#import "PathIterator.h"
#import "Platform.h"
#import "Rectangle.h"
#import "Transform.h"
#import "Transforms.h"
#import "java/lang/Math.h"
#import "java/lang/System.h"
#import "java/util/NoSuchElementException.h"
#import "Area.h"

@implementation PythagorasFArea

- (IOSFloatArray *)coords {
  return coords_;
}
- (void)setCoords:(IOSFloatArray *)coords {
  JreOperatorRetainedAssign(&coords_, self, coords);
}
@synthesize coords = coords_;
@synthesize coordsSize = coordsSize_;
- (IOSIntArray *)rules {
  return rules_;
}
- (void)setRules:(IOSIntArray *)rules {
  JreOperatorRetainedAssign(&rules_, self, rules);
}
@synthesize rules = rules_;
@synthesize rulesSize = rulesSize_;
- (IOSIntArray *)offsets {
  return offsets_;
}
- (void)setOffsets:(IOSIntArray *)offsets {
  JreOperatorRetainedAssign(&offsets_, self, offsets);
}
@synthesize offsets = offsets_;
@synthesize moveToCount = moveToCount_;
@synthesize isPolygonal_ = isPolygonal__;

- (id)init {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&coords_, self, [[[IOSFloatArray alloc] initWithLength:20] autorelease]);
    coordsSize_ = 0;
    JreOperatorRetainedAssign(&rules_, self, [[[IOSIntArray alloc] initWithLength:10] autorelease]);
    rulesSize_ = 0;
    JreOperatorRetainedAssign(&offsets_, self, [[[IOSIntArray alloc] initWithLength:10] autorelease]);
    moveToCount_ = 0;
    isPolygonal__ = YES;
  }
  return self;
}

- (id)initWithPythagorasFIShape:(id<PythagorasFIShape>)s {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&coords_, self, [[[IOSFloatArray alloc] initWithLength:20] autorelease]);
    coordsSize_ = 0;
    JreOperatorRetainedAssign(&rules_, self, [[[IOSIntArray alloc] initWithLength:10] autorelease]);
    rulesSize_ = 0;
    JreOperatorRetainedAssign(&offsets_, self, [[[IOSIntArray alloc] initWithLength:10] autorelease]);
    moveToCount_ = 0;
    isPolygonal__ = YES;
    IOSFloatArray *segmentCoords = [[[IOSFloatArray alloc] initWithLength:6] autorelease];
    float lastMoveX = 0.0f;
    float lastMoveY = 0.0f;
    int rulesIndex = 0;
    int coordsIndex = 0;
    for (id<PythagorasFPathIterator> pi = [((id<PythagorasFIShape>) NIL_CHK(s)) pathIteratorWithPythagorasFTransform:nil]; ![((id<PythagorasFPathIterator>) NIL_CHK(pi)) isDone]; [((id<PythagorasFPathIterator>) NIL_CHK(pi)) next]) {
      JreOperatorRetainedAssign(&coords_, self, [PythagorasFArea adjustSizeWithJavaLangFloatArray:coords_ withInt:coordsIndex + 6]);
      JreOperatorRetainedAssign(&rules_, self, [PythagorasFArea adjustSizeWithJavaLangIntegerArray:rules_ withInt:rulesIndex + 1]);
      JreOperatorRetainedAssign(&offsets_, self, [PythagorasFArea adjustSizeWithJavaLangIntegerArray:offsets_ withInt:rulesIndex + 1]);
      [((IOSIntArray *) NIL_CHK(rules_)) replaceIntAtIndex:rulesIndex withInt:[((id<PythagorasFPathIterator>) NIL_CHK(pi)) currentSegmentWithJavaLangFloatArray:segmentCoords]];
      [((IOSIntArray *) NIL_CHK(offsets_)) replaceIntAtIndex:rulesIndex withInt:coordsIndex];
      switch ([((IOSIntArray *) NIL_CHK(rules_)) intAtIndex:rulesIndex]) {
        case PythagorasFPathIterator_SEG_MOVETO:
        [((IOSFloatArray *) NIL_CHK(coords_)) replaceFloatAtIndex:coordsIndex++ withFloat:[((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:0]];
        [((IOSFloatArray *) NIL_CHK(coords_)) replaceFloatAtIndex:coordsIndex++ withFloat:[((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:1]];
        lastMoveX = [((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:0];
        lastMoveY = [((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:1];
        ++moveToCount_;
        break;
        case PythagorasFPathIterator_SEG_LINETO:
        if (([((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:0] != lastMoveX) || ([((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:1] != lastMoveY)) {
          [((IOSFloatArray *) NIL_CHK(coords_)) replaceFloatAtIndex:coordsIndex++ withFloat:[((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:0]];
          [((IOSFloatArray *) NIL_CHK(coords_)) replaceFloatAtIndex:coordsIndex++ withFloat:[((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:1]];
        }
        else {
          --rulesIndex;
        }
        break;
        case PythagorasFPathIterator_SEG_QUADTO:
        [JavaLangSystem arraycopyWithId:segmentCoords withInt:0 withId:coords_ withInt:coordsIndex withInt:4];
        coordsIndex += 4;
        isPolygonal__ = NO;
        break;
        case PythagorasFPathIterator_SEG_CUBICTO:
        [JavaLangSystem arraycopyWithId:segmentCoords withInt:0 withId:coords_ withInt:coordsIndex withInt:6];
        coordsIndex += 6;
        isPolygonal__ = NO;
        break;
        case PythagorasFPathIterator_SEG_CLOSE:
        break;
      }
      ++rulesIndex;
    }
    if ((rulesIndex != 0) && ([((IOSIntArray *) NIL_CHK(rules_)) intAtIndex:rulesIndex - 1] != PythagorasFPathIterator_SEG_CLOSE)) {
      [((IOSIntArray *) NIL_CHK(rules_)) replaceIntAtIndex:rulesIndex withInt:PythagorasFPathIterator_SEG_CLOSE];
      [((IOSIntArray *) NIL_CHK(offsets_)) replaceIntAtIndex:rulesIndex withInt:coordsSize_];
    }
    rulesSize_ = rulesIndex;
    coordsSize_ = coordsIndex;
  }
  return self;
}

- (BOOL)isPolygonal {
  return isPolygonal__;
}

- (BOOL)isRectangular {
  return (isPolygonal__) && (rulesSize_ <= 5) && (coordsSize_ <= 8) && ([((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:1] == [((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:3]) && ([((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:7] == [((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:5]) && ([((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:0] == [((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:6]) && ([((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2] == [((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:4]);
}

- (BOOL)isSingular {
  return (moveToCount_ <= 1);
}

- (void)reset {
  coordsSize_ = 0;
  rulesSize_ = 0;
}

- (void)transformWithPythagorasFTransform:(id<PythagorasFTransform>)t {
  [self copy__WithPythagorasFArea:[[[PythagorasFArea alloc] initWithPythagorasFIShape:[PythagorasFTransforms createTransformedShapeWithPythagorasFTransform:t withPythagorasFIShape:self]] autorelease] withPythagorasFArea:self];
}

- (PythagorasFArea *)createTransformedAreaWithPythagorasFTransform:(id<PythagorasFTransform>)t {
  return [[[PythagorasFArea alloc] initWithPythagorasFIShape:[PythagorasFTransforms createTransformedShapeWithPythagorasFTransform:t withPythagorasFIShape:self]] autorelease];
}

- (void)addWithPythagorasFArea:(PythagorasFArea *)area {
  if (area == nil || [((PythagorasFArea *) NIL_CHK(area)) isEmpty]) {
    return;
  }
  else if ([self isEmpty]) {
    [self copy__WithPythagorasFArea:area withPythagorasFArea:self];
    return;
  }
  if ([self isPolygonal] && [((PythagorasFArea *) NIL_CHK(area)) isPolygonal]) {
    [self addPolygonWithPythagorasFArea:area];
  }
  else {
    [self addCurvePolygonWithPythagorasFArea:area];
  }
  if ([self areaBoundsSquare] < [PythagorasFGeometryUtil EPSILON]) {
    [self reset];
  }
}

- (void)intersectWithPythagorasFArea:(PythagorasFArea *)area {
  if (area == nil) {
    return;
  }
  else if ([self isEmpty] || [area isEmpty]) {
    [self reset];
    return;
  }
  if ([self isPolygonal] && [((PythagorasFArea *) NIL_CHK(area)) isPolygonal]) {
    [self intersectPolygonWithPythagorasFArea:area];
  }
  else {
    [self intersectCurvePolygonWithPythagorasFArea:area];
  }
  if ([self areaBoundsSquare] < [PythagorasFGeometryUtil EPSILON]) {
    [self reset];
  }
}

- (void)subtractWithPythagorasFArea:(PythagorasFArea *)area {
  if (area == nil || [self isEmpty] || [((PythagorasFArea *) NIL_CHK(area)) isEmpty]) {
    return;
  }
  if ([self isPolygonal] && [((PythagorasFArea *) NIL_CHK(area)) isPolygonal]) {
    [self subtractPolygonWithPythagorasFArea:area];
  }
  else {
    [self subtractCurvePolygonWithPythagorasFArea:area];
  }
  if ([self areaBoundsSquare] < [PythagorasFGeometryUtil EPSILON]) {
    [self reset];
  }
}

- (void)exclusiveOrWithPythagorasFArea:(PythagorasFArea *)area {
  PythagorasFArea *a = [self clone];
  [((PythagorasFArea *) NIL_CHK(a)) intersectWithPythagorasFArea:area];
  [self addWithPythagorasFArea:area];
  [self subtractWithPythagorasFArea:a];
}

- (BOOL)isEmpty {
  return (rulesSize_ == 0) && (coordsSize_ == 0);
}

- (BOOL)containsWithFloat:(float)x
                withFloat:(float)y {
  return ![self isEmpty] && [self containsExactWithFloat:x withFloat:y] > 0;
}

- (BOOL)containsWithFloat:(float)x
                withFloat:(float)y
                withFloat:(float)width
                withFloat:(float)height {
  int crossCount = [PythagorasFCrossing intersectPathWithPythagorasFPathIterator:[self pathIteratorWithPythagorasFTransform:nil] withFloat:x withFloat:y withFloat:width withFloat:height];
  return crossCount != PythagorasFCrossing_CROSSING && [PythagorasFCrossing isInsideEvenOddWithInt:crossCount];
}

- (BOOL)containsWithPythagorasFIPoint:(id<PythagorasFIPoint>)p {
  return [self containsWithFloat:[((id<PythagorasFIPoint>) NIL_CHK(p)) x] withFloat:[((id<PythagorasFIPoint>) NIL_CHK(p)) y]];
}

- (BOOL)containsWithPythagorasFIRectangle:(id<PythagorasFIRectangle>)r {
  return [self containsWithFloat:[((id<PythagorasFIRectangle>) NIL_CHK(r)) x] withFloat:[((id<PythagorasFIRectangle>) NIL_CHK(r)) y] withFloat:[((id<PythagorasFIRectangle>) NIL_CHK(r)) width] withFloat:[((id<PythagorasFIRectangle>) NIL_CHK(r)) height]];
}

- (BOOL)intersectsWithFloat:(float)x
                  withFloat:(float)y
                  withFloat:(float)width
                  withFloat:(float)height {
  if ((width <= 0.0f) || (height <= 0.0f)) {
    return NO;
  }
  else if (![[self bounds] intersectsWithFloat:x withFloat:y withFloat:width withFloat:height]) {
    return NO;
  }
  int crossCount = [PythagorasFCrossing intersectShapeWithPythagorasFIShape:self withFloat:x withFloat:y withFloat:width withFloat:height];
  return [PythagorasFCrossing isInsideEvenOddWithInt:crossCount];
}

- (BOOL)intersectsWithPythagorasFIRectangle:(id<PythagorasFIRectangle>)r {
  return [self intersectsWithFloat:[((id<PythagorasFIRectangle>) NIL_CHK(r)) x] withFloat:[((id<PythagorasFIRectangle>) NIL_CHK(r)) y] withFloat:[((id<PythagorasFIRectangle>) NIL_CHK(r)) width] withFloat:[((id<PythagorasFIRectangle>) NIL_CHK(r)) height]];
}

- (PythagorasFRectangle *)bounds {
  return [self boundsWithPythagorasFRectangle:[[[PythagorasFRectangle alloc] init] autorelease]];
}

- (PythagorasFRectangle *)boundsWithPythagorasFRectangle:(PythagorasFRectangle *)target {
  float maxX = [((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:0], maxY = [((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:1];
  float minX = [((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:0], minY = [((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:1];
  for (int i = 0; i < coordsSize_; ) {
    minX = [JavaLangMath minWithFloat:minX withFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:i]];
    maxX = [JavaLangMath maxWithFloat:maxX withFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:i++]];
    minY = [JavaLangMath minWithFloat:minY withFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:i]];
    maxY = [JavaLangMath maxWithFloat:maxY withFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:i++]];
  }
  return [[[PythagorasFRectangle alloc] initWithFloat:minX withFloat:minY withFloat:maxX - minX withFloat:maxY - minY] autorelease];
}

- (id<PythagorasFPathIterator>)pathIteratorWithPythagorasFTransform:(id<PythagorasFTransform>)t {
  return [[[PythagorasFArea_AreaPathIterator alloc] initWithPythagorasFArea:self withPythagorasFTransform:t] autorelease];
}

- (id<PythagorasFPathIterator>)pathIteratorWithPythagorasFTransform:(id<PythagorasFTransform>)t
                                                          withFloat:(float)flatness {
  return [[[PythagorasFFlatteningPathIterator alloc] initWithPythagorasFPathIterator:[self pathIteratorWithPythagorasFTransform:t] withFloat:flatness] autorelease];
}

- (BOOL)isEqual:(id)obj {
  if (self == obj) {
    return YES;
  }
  else if (!([obj isKindOfClass:[PythagorasFArea class]])) {
    return NO;
  }
  PythagorasFArea *area = [self clone];
  [((PythagorasFArea *) NIL_CHK(area)) subtractWithPythagorasFArea:(PythagorasFArea *) obj];
  return [((PythagorasFArea *) NIL_CHK(area)) isEmpty];
}

- (PythagorasFArea *)clone {
  PythagorasFArea *area = [[[PythagorasFArea alloc] init] autorelease];
  [self copy__WithPythagorasFArea:self withPythagorasFArea:area];
  return area;
}

- (void)addCurvePolygonWithPythagorasFArea:(PythagorasFArea *)area {
  PythagorasFCurveCrossingHelper *crossHelper = [[[PythagorasFCurveCrossingHelper alloc] initWithJavaLangFloatArray:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasFArea *) NIL_CHK(area)).coords } count:2 type:[IOSClass classWithClass:[IOSFloatArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasFArea *) NIL_CHK(area)).coordsSize } count:2] withJavaLangIntegerArray:[IOSObjectArray arrayWithObjects:(id[]){ rules_, ((PythagorasFArea *) NIL_CHK(area)).rules } count:2 type:[IOSClass classWithClass:[IOSIntArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ rulesSize_, ((PythagorasFArea *) NIL_CHK(area)).rulesSize } count:2] withJavaLangIntegerArray:[IOSObjectArray arrayWithObjects:(id[]){ offsets_, ((PythagorasFArea *) NIL_CHK(area)).offsets } count:2 type:[IOSClass classWithClass:[IOSIntArray class]]]] autorelease];
  IOSObjectArray *intersectPoints = [((PythagorasFCurveCrossingHelper *) NIL_CHK(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count] == 0) {
    if ([((PythagorasFArea *) NIL_CHK(area)) containsWithPythagorasFIRectangle:[self bounds]]) {
      [self copy__WithPythagorasFArea:area withPythagorasFArea:self];
    }
    else if (![self containsWithPythagorasFIRectangle:[((PythagorasFArea *) NIL_CHK(area)) bounds]]) {
      JreOperatorRetainedAssign(&coords_, self, [PythagorasFArea adjustSizeWithJavaLangFloatArray:coords_ withInt:coordsSize_ + ((PythagorasFArea *) NIL_CHK(area)).coordsSize]);
      [JavaLangSystem arraycopyWithId:((PythagorasFArea *) NIL_CHK(area)).coords withInt:0 withId:coords_ withInt:coordsSize_ withInt:((PythagorasFArea *) NIL_CHK(area)).coordsSize];
      coordsSize_ += ((PythagorasFArea *) NIL_CHK(area)).coordsSize;
      JreOperatorRetainedAssign(&rules_, self, [PythagorasFArea adjustSizeWithJavaLangIntegerArray:rules_ withInt:rulesSize_ + ((PythagorasFArea *) NIL_CHK(area)).rulesSize]);
      [JavaLangSystem arraycopyWithId:((PythagorasFArea *) NIL_CHK(area)).rules withInt:0 withId:rules_ withInt:rulesSize_ withInt:((PythagorasFArea *) NIL_CHK(area)).rulesSize];
      rulesSize_ += ((PythagorasFArea *) NIL_CHK(area)).rulesSize;
      JreOperatorRetainedAssign(&offsets_, self, [PythagorasFArea adjustSizeWithJavaLangIntegerArray:offsets_ withInt:rulesSize_ + ((PythagorasFArea *) NIL_CHK(area)).rulesSize]);
      [JavaLangSystem arraycopyWithId:((PythagorasFArea *) NIL_CHK(area)).offsets withInt:0 withId:offsets_ withInt:rulesSize_ withInt:((PythagorasFArea *) NIL_CHK(area)).rulesSize];
    }
    return;
  }
  IOSFloatArray *resultCoords = [[[IOSFloatArray alloc] initWithLength:coordsSize_ + ((PythagorasFArea *) NIL_CHK(area)).coordsSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultRules = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasFArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultOffsets = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasFArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasFIntersectPoint *point = ((PythagorasFIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]);
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_MOVETO];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
  do {
    [((IOSFloatArray *) NIL_CHK(resultCoords)) replaceFloatAtIndex:resultCoordPos++ withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) x]];
    [((IOSFloatArray *) NIL_CHK(resultCoords)) replaceFloatAtIndex:resultCoordPos++ withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) y]];
    int curIndex = [((PythagorasFIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:YES];
    if (curIndex < 0) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasFArea *) NIL_CHK(area)) containsExactWithFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex] withFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = NO;
    }
    else {
      isCurrentArea = YES;
    }
    PythagorasFIntersectPoint *nextPoint = [self nextIntersectPointWithPythagorasFIntersectPointArray:intersectPoints withPythagorasFIntersectPoint:point withBOOL:isCurrentArea];
    IOSFloatArray *coords = (isCurrentArea) ? self.coords : ((PythagorasFArea *) NIL_CHK(area)).coords;
    IOSIntArray *offsets = (isCurrentArea) ? self.offsets : ((PythagorasFArea *) NIL_CHK(area)).offsets;
    IOSIntArray *rules = (isCurrentArea) ? self.rules : ((PythagorasFArea *) NIL_CHK(area)).rules;
    int offset = [((PythagorasFIntersectPoint *) NIL_CHK(point)) ruleIndexWithBOOL:isCurrentArea];
    BOOL isCopyUntilZero = NO;
    if (([((PythagorasFIntersectPoint *) NIL_CHK(point)) ruleIndexWithBOOL:isCurrentArea] > [((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea])) {
      int rulesSize = (isCurrentArea) ? self.rulesSize : ((PythagorasFArea *) NIL_CHK(area)).rulesSize;
      resultCoordPos = [self includeCoordsAndRulesWithInt:offset + 1 withInt:rulesSize withJavaLangIntegerArray:rules withJavaLangIntegerArray:offsets withJavaLangIntegerArray:resultRules withJavaLangIntegerArray:resultOffsets withJavaLangFloatArray:resultCoords withJavaLangFloatArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasFIntersectPoint:point withBOOL:isCurrentArea withBOOL:NO withInt:0];
      resultRulesPos += rulesSize - offset - 1;
      offset = 1;
      isCopyUntilZero = YES;
    }
    int length = [((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea] - offset + 1;
    if (isCopyUntilZero) {
      offset = 0;
    }
    resultCoordPos = [self includeCoordsAndRulesWithInt:offset withInt:length withJavaLangIntegerArray:rules withJavaLangIntegerArray:offsets withJavaLangIntegerArray:resultRules withJavaLangIntegerArray:resultOffsets withJavaLangFloatArray:resultCoords withJavaLangFloatArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasFIntersectPoint:point withBOOL:isCurrentArea withBOOL:YES withInt:0];
    resultRulesPos += length - offset;
    point = nextPoint;
  }
  while (point != ((PythagorasFIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]));
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos++ withInt:PythagorasFPathIterator_SEG_CLOSE];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos - 1 withInt:resultCoordPos];
  self.coords = resultCoords;
  self.rules = resultRules;
  self.offsets = resultOffsets;
  self.coordsSize = resultCoordPos;
  self.rulesSize = resultRulesPos;
}

- (void)addPolygonWithPythagorasFArea:(PythagorasFArea *)area {
  PythagorasFCrossingHelper *crossHelper = [[[PythagorasFCrossingHelper alloc] initWithJavaLangFloatArray:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasFArea *) NIL_CHK(area)).coords } count:2 type:[IOSClass classWithClass:[IOSFloatArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasFArea *) NIL_CHK(area)).coordsSize } count:2]] autorelease];
  IOSObjectArray *intersectPoints = [((PythagorasFCrossingHelper *) NIL_CHK(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count] == 0) {
    if ([((PythagorasFArea *) NIL_CHK(area)) containsWithPythagorasFIRectangle:[self bounds]]) {
      [self copy__WithPythagorasFArea:area withPythagorasFArea:self];
    }
    else if (![self containsWithPythagorasFIRectangle:[((PythagorasFArea *) NIL_CHK(area)) bounds]]) {
      JreOperatorRetainedAssign(&coords_, self, [PythagorasFArea adjustSizeWithJavaLangFloatArray:coords_ withInt:coordsSize_ + ((PythagorasFArea *) NIL_CHK(area)).coordsSize]);
      [JavaLangSystem arraycopyWithId:((PythagorasFArea *) NIL_CHK(area)).coords withInt:0 withId:coords_ withInt:coordsSize_ withInt:((PythagorasFArea *) NIL_CHK(area)).coordsSize];
      coordsSize_ += ((PythagorasFArea *) NIL_CHK(area)).coordsSize;
      JreOperatorRetainedAssign(&rules_, self, [PythagorasFArea adjustSizeWithJavaLangIntegerArray:rules_ withInt:rulesSize_ + ((PythagorasFArea *) NIL_CHK(area)).rulesSize]);
      [JavaLangSystem arraycopyWithId:((PythagorasFArea *) NIL_CHK(area)).rules withInt:0 withId:rules_ withInt:rulesSize_ withInt:((PythagorasFArea *) NIL_CHK(area)).rulesSize];
      rulesSize_ += ((PythagorasFArea *) NIL_CHK(area)).rulesSize;
      JreOperatorRetainedAssign(&offsets_, self, [PythagorasFArea adjustSizeWithJavaLangIntegerArray:offsets_ withInt:rulesSize_ + ((PythagorasFArea *) NIL_CHK(area)).rulesSize]);
      [JavaLangSystem arraycopyWithId:((PythagorasFArea *) NIL_CHK(area)).offsets withInt:0 withId:offsets_ withInt:rulesSize_ withInt:((PythagorasFArea *) NIL_CHK(area)).rulesSize];
    }
    return;
  }
  IOSFloatArray *resultCoords = [[[IOSFloatArray alloc] initWithLength:coordsSize_ + ((PythagorasFArea *) NIL_CHK(area)).coordsSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultRules = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasFArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultOffsets = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasFArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasFIntersectPoint *point = ((PythagorasFIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]);
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_MOVETO];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
  do {
    [((IOSFloatArray *) NIL_CHK(resultCoords)) replaceFloatAtIndex:resultCoordPos++ withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) x]];
    [((IOSFloatArray *) NIL_CHK(resultCoords)) replaceFloatAtIndex:resultCoordPos++ withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) y]];
    [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_LINETO];
    [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos - 2];
    int curIndex = [((PythagorasFIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:YES];
    if (curIndex < 0) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasFArea *) NIL_CHK(area)) containsExactWithFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex] withFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = NO;
    }
    else {
      isCurrentArea = YES;
    }
    PythagorasFIntersectPoint *nextPoint = [self nextIntersectPointWithPythagorasFIntersectPointArray:intersectPoints withPythagorasFIntersectPoint:point withBOOL:isCurrentArea];
    IOSFloatArray *coords = (isCurrentArea) ? self.coords : ((PythagorasFArea *) NIL_CHK(area)).coords;
    int offset = 2 * [((PythagorasFIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:isCurrentArea];
    if ((offset >= 0) && ([((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) begIndexWithBOOL:isCurrentArea] < [((PythagorasFIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:isCurrentArea])) {
      int coordSize = (isCurrentArea) ? self.coordsSize : ((PythagorasFArea *) NIL_CHK(area)).coordsSize;
      int length = coordSize - offset;
      [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      for (int i = 0; i < length / 2; i++) {
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_LINETO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
        resultCoordPos += 2;
      }
      offset = 0;
    }
    if (offset >= 0) {
      int length = 2 * [((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) begIndexWithBOOL:isCurrentArea] - offset + 2;
      [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      for (int i = 0; i < length / 2; i++) {
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_LINETO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
        resultCoordPos += 2;
      }
    }
    point = nextPoint;
  }
  while (point != ((PythagorasFIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]));
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos - 1 withInt:PythagorasFPathIterator_SEG_CLOSE];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos - 1 withInt:resultCoordPos];
  JreOperatorRetainedAssign(&coords_, self, resultCoords);
  JreOperatorRetainedAssign(&rules_, self, resultRules);
  JreOperatorRetainedAssign(&offsets_, self, resultOffsets);
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (void)intersectCurvePolygonWithPythagorasFArea:(PythagorasFArea *)area {
  PythagorasFCurveCrossingHelper *crossHelper = [[[PythagorasFCurveCrossingHelper alloc] initWithJavaLangFloatArray:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasFArea *) NIL_CHK(area)).coords } count:2 type:[IOSClass classWithClass:[IOSFloatArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasFArea *) NIL_CHK(area)).coordsSize } count:2] withJavaLangIntegerArray:[IOSObjectArray arrayWithObjects:(id[]){ rules_, ((PythagorasFArea *) NIL_CHK(area)).rules } count:2 type:[IOSClass classWithClass:[IOSIntArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ rulesSize_, ((PythagorasFArea *) NIL_CHK(area)).rulesSize } count:2] withJavaLangIntegerArray:[IOSObjectArray arrayWithObjects:(id[]){ offsets_, ((PythagorasFArea *) NIL_CHK(area)).offsets } count:2 type:[IOSClass classWithClass:[IOSIntArray class]]]] autorelease];
  IOSObjectArray *intersectPoints = [((PythagorasFCurveCrossingHelper *) NIL_CHK(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count] == 0) {
    if ([self containsWithPythagorasFIRectangle:[((PythagorasFArea *) NIL_CHK(area)) bounds]]) {
      [self copy__WithPythagorasFArea:area withPythagorasFArea:self];
    }
    else if (![((PythagorasFArea *) NIL_CHK(area)) containsWithPythagorasFIRectangle:[self bounds]]) {
      [self reset];
    }
    return;
  }
  IOSFloatArray *resultCoords = [[[IOSFloatArray alloc] initWithLength:coordsSize_ + ((PythagorasFArea *) NIL_CHK(area)).coordsSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultRules = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasFArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultOffsets = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasFArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasFIntersectPoint *point = ((PythagorasFIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]);
  PythagorasFIntersectPoint *nextPoint = ((PythagorasFIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]);
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_MOVETO];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
  do {
    [((IOSFloatArray *) NIL_CHK(resultCoords)) replaceFloatAtIndex:resultCoordPos++ withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) x]];
    [((IOSFloatArray *) NIL_CHK(resultCoords)) replaceFloatAtIndex:resultCoordPos++ withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) y]];
    int curIndex = [((PythagorasFIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:YES];
    if ((curIndex < 0) || ([((PythagorasFArea *) NIL_CHK(area)) containsExactWithFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex] withFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex + 1]] == 0)) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasFArea *) NIL_CHK(area)) containsExactWithFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex] withFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = YES;
    }
    else {
      isCurrentArea = NO;
    }
    nextPoint = [self nextIntersectPointWithPythagorasFIntersectPointArray:intersectPoints withPythagorasFIntersectPoint:point withBOOL:isCurrentArea];
    IOSFloatArray *coords = (isCurrentArea) ? self.coords : ((PythagorasFArea *) NIL_CHK(area)).coords;
    IOSIntArray *offsets = (isCurrentArea) ? self.offsets : ((PythagorasFArea *) NIL_CHK(area)).offsets;
    IOSIntArray *rules = (isCurrentArea) ? self.rules : ((PythagorasFArea *) NIL_CHK(area)).rules;
    int offset = [((PythagorasFIntersectPoint *) NIL_CHK(point)) ruleIndexWithBOOL:isCurrentArea];
    BOOL isCopyUntilZero = NO;
    if ([((PythagorasFIntersectPoint *) NIL_CHK(point)) ruleIndexWithBOOL:isCurrentArea] > [((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea]) {
      int rulesSize = (isCurrentArea) ? self.rulesSize : ((PythagorasFArea *) NIL_CHK(area)).rulesSize;
      resultCoordPos = [self includeCoordsAndRulesWithInt:offset + 1 withInt:rulesSize withJavaLangIntegerArray:rules withJavaLangIntegerArray:offsets withJavaLangIntegerArray:resultRules withJavaLangIntegerArray:resultOffsets withJavaLangFloatArray:resultCoords withJavaLangFloatArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasFIntersectPoint:point withBOOL:isCurrentArea withBOOL:NO withInt:1];
      resultRulesPos += rulesSize - offset - 1;
      offset = 1;
      isCopyUntilZero = YES;
    }
    int length = [((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea] - offset + 1;
    if (isCopyUntilZero) {
      offset = 0;
      isCopyUntilZero = NO;
    }
    if ((length == offset) && ([((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) ruleWithBOOL:isCurrentArea] != PythagorasFPathIterator_SEG_LINETO) && ([((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) ruleWithBOOL:isCurrentArea] != PythagorasFPathIterator_SEG_CLOSE) && ([((PythagorasFIntersectPoint *) NIL_CHK(point)) ruleWithBOOL:isCurrentArea] != PythagorasFPathIterator_SEG_LINETO) && ([((PythagorasFIntersectPoint *) NIL_CHK(point)) ruleWithBOOL:isCurrentArea] != PythagorasFPathIterator_SEG_CLOSE)) {
      isCopyUntilZero = YES;
      length++;
    }
    resultCoordPos = [self includeCoordsAndRulesWithInt:offset withInt:length withJavaLangIntegerArray:rules withJavaLangIntegerArray:offsets withJavaLangIntegerArray:resultRules withJavaLangIntegerArray:resultOffsets withJavaLangFloatArray:resultCoords withJavaLangFloatArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasFIntersectPoint:nextPoint withBOOL:isCurrentArea withBOOL:YES withInt:1];
    resultRulesPos = ((length <= offset) || (isCopyUntilZero)) ? resultRulesPos + 1 : resultRulesPos + length;
    point = nextPoint;
  }
  while (point != ((PythagorasFIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]));
  if ([((IOSIntArray *) NIL_CHK(resultRules)) intAtIndex:resultRulesPos - 1] == PythagorasFPathIterator_SEG_LINETO) {
    [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos - 1 withInt:PythagorasFPathIterator_SEG_CLOSE];
  }
  else {
    [((IOSFloatArray *) NIL_CHK(resultCoords)) replaceFloatAtIndex:resultCoordPos++ withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) x]];
    [((IOSFloatArray *) NIL_CHK(resultCoords)) replaceFloatAtIndex:resultCoordPos++ withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) y]];
    [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos++ withInt:PythagorasFPathIterator_SEG_CLOSE];
  }
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos - 1 withInt:resultCoordPos];
  JreOperatorRetainedAssign(&coords_, self, resultCoords);
  JreOperatorRetainedAssign(&rules_, self, resultRules);
  JreOperatorRetainedAssign(&offsets_, self, resultOffsets);
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (void)intersectPolygonWithPythagorasFArea:(PythagorasFArea *)area {
  PythagorasFCrossingHelper *crossHelper = [[[PythagorasFCrossingHelper alloc] initWithJavaLangFloatArray:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasFArea *) NIL_CHK(area)).coords } count:2 type:[IOSClass classWithClass:[IOSFloatArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasFArea *) NIL_CHK(area)).coordsSize } count:2]] autorelease];
  IOSObjectArray *intersectPoints = [((PythagorasFCrossingHelper *) NIL_CHK(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count] == 0) {
    if ([self containsWithPythagorasFIRectangle:[((PythagorasFArea *) NIL_CHK(area)) bounds]]) {
      [self copy__WithPythagorasFArea:area withPythagorasFArea:self];
    }
    else if (![((PythagorasFArea *) NIL_CHK(area)) containsWithPythagorasFIRectangle:[self bounds]]) {
      [self reset];
    }
    return;
  }
  IOSFloatArray *resultCoords = [[[IOSFloatArray alloc] initWithLength:coordsSize_ + ((PythagorasFArea *) NIL_CHK(area)).coordsSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultRules = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasFArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultOffsets = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasFArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasFIntersectPoint *point = ((PythagorasFIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]);
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_MOVETO];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
  do {
    [((IOSFloatArray *) NIL_CHK(resultCoords)) replaceFloatAtIndex:resultCoordPos++ withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) x]];
    [((IOSFloatArray *) NIL_CHK(resultCoords)) replaceFloatAtIndex:resultCoordPos++ withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) y]];
    [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_LINETO];
    [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos - 2];
    int curIndex = [((PythagorasFIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:YES];
    if ((curIndex < 0) || ([((PythagorasFArea *) NIL_CHK(area)) containsExactWithFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex] withFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex + 1]] == 0)) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasFArea *) NIL_CHK(area)) containsExactWithFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex] withFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = YES;
    }
    else {
      isCurrentArea = NO;
    }
    PythagorasFIntersectPoint *nextPoint = [self nextIntersectPointWithPythagorasFIntersectPointArray:intersectPoints withPythagorasFIntersectPoint:point withBOOL:isCurrentArea];
    IOSFloatArray *coords = (isCurrentArea) ? self.coords : ((PythagorasFArea *) NIL_CHK(area)).coords;
    int offset = 2 * [((PythagorasFIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:isCurrentArea];
    if ((offset >= 0) && ([((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) begIndexWithBOOL:isCurrentArea] < [((PythagorasFIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:isCurrentArea])) {
      int coordSize = (isCurrentArea) ? self.coordsSize : ((PythagorasFArea *) NIL_CHK(area)).coordsSize;
      int length = coordSize - offset;
      [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      for (int i = 0; i < length / 2; i++) {
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_LINETO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
        resultCoordPos += 2;
      }
      offset = 0;
    }
    if (offset >= 0) {
      int length = 2 * [((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) begIndexWithBOOL:isCurrentArea] - offset + 2;
      [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      for (int i = 0; i < length / 2; i++) {
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_LINETO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
        resultCoordPos += 2;
      }
    }
    point = nextPoint;
  }
  while (point != ((PythagorasFIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]));
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos - 1 withInt:PythagorasFPathIterator_SEG_CLOSE];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos - 1 withInt:resultCoordPos];
  JreOperatorRetainedAssign(&coords_, self, resultCoords);
  JreOperatorRetainedAssign(&rules_, self, resultRules);
  JreOperatorRetainedAssign(&offsets_, self, resultOffsets);
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (void)subtractCurvePolygonWithPythagorasFArea:(PythagorasFArea *)area {
  PythagorasFCurveCrossingHelper *crossHelper = [[[PythagorasFCurveCrossingHelper alloc] initWithJavaLangFloatArray:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasFArea *) NIL_CHK(area)).coords } count:2 type:[IOSClass classWithClass:[IOSFloatArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasFArea *) NIL_CHK(area)).coordsSize } count:2] withJavaLangIntegerArray:[IOSObjectArray arrayWithObjects:(id[]){ rules_, ((PythagorasFArea *) NIL_CHK(area)).rules } count:2 type:[IOSClass classWithClass:[IOSIntArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ rulesSize_, ((PythagorasFArea *) NIL_CHK(area)).rulesSize } count:2] withJavaLangIntegerArray:[IOSObjectArray arrayWithObjects:(id[]){ offsets_, ((PythagorasFArea *) NIL_CHK(area)).offsets } count:2 type:[IOSClass classWithClass:[IOSIntArray class]]]] autorelease];
  IOSObjectArray *intersectPoints = [((PythagorasFCurveCrossingHelper *) NIL_CHK(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count] == 0 && [self containsWithPythagorasFIRectangle:[((PythagorasFArea *) NIL_CHK(area)) bounds]]) {
    [self copy__WithPythagorasFArea:area withPythagorasFArea:self];
    return;
  }
  IOSFloatArray *resultCoords = [[[IOSFloatArray alloc] initWithLength:coordsSize_ + ((PythagorasFArea *) NIL_CHK(area)).coordsSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultRules = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasFArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultOffsets = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasFArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasFIntersectPoint *point = ((PythagorasFIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]);
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_MOVETO];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
  do {
    [((IOSFloatArray *) NIL_CHK(resultCoords)) replaceFloatAtIndex:resultCoordPos++ withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) x]];
    [((IOSFloatArray *) NIL_CHK(resultCoords)) replaceFloatAtIndex:resultCoordPos++ withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) y]];
    int curIndex = [((IOSIntArray *) NIL_CHK(offsets_)) intAtIndex:[((PythagorasFIntersectPoint *) NIL_CHK(point)) ruleIndexWithBOOL:YES]] % coordsSize_;
    if ([((PythagorasFArea *) NIL_CHK(area)) containsExactWithFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:curIndex] withFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:curIndex + 1]] == 0) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasFArea *) NIL_CHK(area)) containsExactWithFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:curIndex] withFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:curIndex + 1]] > 0) {
      isCurrentArea = NO;
    }
    else {
      isCurrentArea = YES;
    }
    PythagorasFIntersectPoint *nextPoint = (isCurrentArea) ? [self nextIntersectPointWithPythagorasFIntersectPointArray:intersectPoints withPythagorasFIntersectPoint:point withBOOL:isCurrentArea] : [self prevIntersectPointWithPythagorasFIntersectPointArray:intersectPoints withPythagorasFIntersectPoint:point withBOOL:isCurrentArea];
    IOSFloatArray *coords = (isCurrentArea) ? self.coords : ((PythagorasFArea *) NIL_CHK(area)).coords;
    IOSIntArray *offsets = (isCurrentArea) ? self.offsets : ((PythagorasFArea *) NIL_CHK(area)).offsets;
    IOSIntArray *rules = (isCurrentArea) ? self.rules : ((PythagorasFArea *) NIL_CHK(area)).rules;
    int offset = (isCurrentArea) ? [((PythagorasFIntersectPoint *) NIL_CHK(point)) ruleIndexWithBOOL:isCurrentArea] : [((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea];
    BOOL isCopyUntilZero = NO;
    if (((isCurrentArea) && ([((PythagorasFIntersectPoint *) NIL_CHK(point)) ruleIndexWithBOOL:isCurrentArea] > [((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea])) || ((!isCurrentArea) && ([((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea] > [((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea]))) {
      int rulesSize = (isCurrentArea) ? self.rulesSize : ((PythagorasFArea *) NIL_CHK(area)).rulesSize;
      resultCoordPos = [self includeCoordsAndRulesWithInt:offset + 1 withInt:rulesSize withJavaLangIntegerArray:rules withJavaLangIntegerArray:offsets withJavaLangIntegerArray:resultRules withJavaLangIntegerArray:resultOffsets withJavaLangFloatArray:resultCoords withJavaLangFloatArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasFIntersectPoint:point withBOOL:isCurrentArea withBOOL:NO withInt:2];
      resultRulesPos += rulesSize - offset - 1;
      offset = 1;
      isCopyUntilZero = YES;
    }
    int length = [((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea] - offset + 1;
    if (isCopyUntilZero) {
      offset = 0;
      isCopyUntilZero = NO;
    }
    resultCoordPos = [self includeCoordsAndRulesWithInt:offset withInt:length withJavaLangIntegerArray:rules withJavaLangIntegerArray:offsets withJavaLangIntegerArray:resultRules withJavaLangIntegerArray:resultOffsets withJavaLangFloatArray:resultCoords withJavaLangFloatArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasFIntersectPoint:point withBOOL:isCurrentArea withBOOL:YES withInt:2];
    if ((length == offset) && (([((IOSIntArray *) NIL_CHK(rules)) intAtIndex:offset] == PythagorasFPathIterator_SEG_QUADTO) || ([((IOSIntArray *) NIL_CHK(rules)) intAtIndex:offset] == PythagorasFPathIterator_SEG_CUBICTO))) {
      resultRulesPos++;
    }
    else {
      resultRulesPos = (length < offset || isCopyUntilZero) ? resultRulesPos + 1 : resultRulesPos + length - offset;
    }
    point = nextPoint;
  }
  while (point != ((PythagorasFIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]));
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos++ withInt:PythagorasFPathIterator_SEG_CLOSE];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos - 1 withInt:resultCoordPos];
  JreOperatorRetainedAssign(&coords_, self, resultCoords);
  JreOperatorRetainedAssign(&rules_, self, resultRules);
  JreOperatorRetainedAssign(&offsets_, self, resultOffsets);
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (void)subtractPolygonWithPythagorasFArea:(PythagorasFArea *)area {
  PythagorasFCrossingHelper *crossHelper = [[[PythagorasFCrossingHelper alloc] initWithJavaLangFloatArray:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasFArea *) NIL_CHK(area)).coords } count:2 type:[IOSClass classWithClass:[IOSFloatArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasFArea *) NIL_CHK(area)).coordsSize } count:2]] autorelease];
  IOSObjectArray *intersectPoints = [((PythagorasFCrossingHelper *) NIL_CHK(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count] == 0) {
    if ([self containsWithPythagorasFIRectangle:[((PythagorasFArea *) NIL_CHK(area)) bounds]]) {
      [self copy__WithPythagorasFArea:area withPythagorasFArea:self];
      return;
    }
    return;
  }
  IOSFloatArray *resultCoords = [[[IOSFloatArray alloc] initWithLength:2 * (coordsSize_ + ((PythagorasFArea *) NIL_CHK(area)).coordsSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count])] autorelease];
  IOSIntArray *resultRules = [[[IOSIntArray alloc] initWithLength:2 * (rulesSize_ + ((PythagorasFArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count])] autorelease];
  IOSIntArray *resultOffsets = [[[IOSIntArray alloc] initWithLength:2 * (rulesSize_ + ((PythagorasFArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count])] autorelease];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  int countPoints = 0;
  BOOL curArea = NO;
  BOOL addArea = NO;
  PythagorasFIntersectPoint *point = ((PythagorasFIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]);
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_MOVETO];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
  do {
    [((IOSFloatArray *) NIL_CHK(resultCoords)) replaceFloatAtIndex:resultCoordPos++ withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) x]];
    [((IOSFloatArray *) NIL_CHK(resultCoords)) replaceFloatAtIndex:resultCoordPos++ withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) y]];
    [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_LINETO];
    [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos - 2];
    int curIndex = [((PythagorasFIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:YES];
    if ((curIndex < 0) || ([((PythagorasFArea *) NIL_CHK(area)) isVertexWithFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex] withFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex + 1]] && [((PythagorasFCrossingHelper *) NIL_CHK(crossHelper)) containsPointWithJavaLangFloatArray:[IOSFloatArray arrayWithFloats:(float[]){ [((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex], [((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex + 1] } count:2]] && ([((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex] != [((PythagorasFIntersectPoint *) NIL_CHK(point)) x] || [((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex + 1] != [((PythagorasFIntersectPoint *) NIL_CHK(point)) y]))) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasFArea *) NIL_CHK(area)) containsExactWithFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex] withFloat:[((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = NO;
    }
    else {
      isCurrentArea = YES;
    }
    if (countPoints >= (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]) {
      isCurrentArea = !isCurrentArea;
    }
    if (isCurrentArea) {
      curArea = YES;
    }
    else {
      addArea = YES;
    }
    PythagorasFIntersectPoint *nextPoint = (isCurrentArea) ? [self nextIntersectPointWithPythagorasFIntersectPointArray:intersectPoints withPythagorasFIntersectPoint:point withBOOL:isCurrentArea] : [self prevIntersectPointWithPythagorasFIntersectPointArray:intersectPoints withPythagorasFIntersectPoint:point withBOOL:isCurrentArea];
    IOSFloatArray *coords = (isCurrentArea) ? self.coords : ((PythagorasFArea *) NIL_CHK(area)).coords;
    int offset = (isCurrentArea) ? 2 * [((PythagorasFIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:isCurrentArea] : 2 * [((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) endIndexWithBOOL:isCurrentArea];
    if ((offset > 0) && (((isCurrentArea) && ([((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) begIndexWithBOOL:isCurrentArea] < [((PythagorasFIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:isCurrentArea])) || ((!isCurrentArea) && ([((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) endIndexWithBOOL:isCurrentArea] < [((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) begIndexWithBOOL:isCurrentArea])))) {
      int coordSize = (isCurrentArea) ? self.coordsSize : ((PythagorasFArea *) NIL_CHK(area)).coordsSize;
      int length = coordSize - offset;
      if (isCurrentArea) {
        [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      }
      else {
        IOSFloatArray *temp = [[[IOSFloatArray alloc] initWithLength:length] autorelease];
        [JavaLangSystem arraycopyWithId:coords withInt:offset withId:temp withInt:0 withInt:length];
        [self reverseCopyWithJavaLangFloatArray:temp];
        [JavaLangSystem arraycopyWithId:temp withInt:0 withId:resultCoords withInt:resultCoordPos withInt:length];
      }
      for (int i = 0; i < length / 2; i++) {
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_LINETO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
        resultCoordPos += 2;
      }
      offset = 0;
    }
    if (offset >= 0) {
      int length = (isCurrentArea) ? 2 * [((PythagorasFIntersectPoint *) NIL_CHK(nextPoint)) begIndexWithBOOL:isCurrentArea] - offset + 2 : 2 * [((PythagorasFIntersectPoint *) NIL_CHK(point)) begIndexWithBOOL:isCurrentArea] - offset + 2;
      if (isCurrentArea) {
        [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      }
      else {
        IOSFloatArray *temp = [[[IOSFloatArray alloc] initWithLength:length] autorelease];
        [JavaLangSystem arraycopyWithId:coords withInt:offset withId:temp withInt:0 withInt:length];
        [self reverseCopyWithJavaLangFloatArray:temp];
        [JavaLangSystem arraycopyWithId:temp withInt:0 withId:resultCoords withInt:resultCoordPos withInt:length];
      }
      for (int i = 0; i < length / 2; i++) {
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_LINETO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
        resultCoordPos += 2;
      }
    }
    point = nextPoint;
    countPoints++;
  }
  while (point != ((PythagorasFIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]) || !(curArea && addArea));
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos - 1 withInt:PythagorasFPathIterator_SEG_CLOSE];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos - 1 withInt:resultCoordPos];
  JreOperatorRetainedAssign(&coords_, self, resultCoords);
  JreOperatorRetainedAssign(&rules_, self, resultRules);
  JreOperatorRetainedAssign(&offsets_, self, resultOffsets);
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (PythagorasFIntersectPoint *)nextIntersectPointWithPythagorasFIntersectPointArray:(IOSObjectArray *)iPoints
                                                      withPythagorasFIntersectPoint:(PythagorasFIntersectPoint *)isectPoint
                                                                           withBOOL:(BOOL)isCurrentArea {
  int endIndex = [((PythagorasFIntersectPoint *) NIL_CHK(isectPoint)) endIndexWithBOOL:isCurrentArea];
  if (endIndex < 0) {
    return ((PythagorasFIntersectPoint *) [((IOSObjectArray *) NIL_CHK(iPoints)) objectAtIndex:[JavaLangMath absWithInt:endIndex] - 1]);
  }
  PythagorasFIntersectPoint *firstIsectPoint = nil;
  PythagorasFIntersectPoint *nextIsectPoint = nil;
  {
    IOSObjectArray *a__ = iPoints;
    int n__ = (int) [((IOSObjectArray *) NIL_CHK(a__)) count];
    for (int i__ = 0; i__ < n__; i__++) {
      PythagorasFIntersectPoint *point = ((PythagorasFIntersectPoint *) [((IOSObjectArray *) NIL_CHK(a__)) objectAtIndex:i__]);
      int begIndex = [((PythagorasFIntersectPoint *) NIL_CHK(point)) begIndexWithBOOL:isCurrentArea];
      if (begIndex >= 0) {
        if (firstIsectPoint == nil) {
          firstIsectPoint = point;
        }
        else if (begIndex < [firstIsectPoint begIndexWithBOOL:isCurrentArea]) {
          firstIsectPoint = point;
        }
      }
      if (endIndex <= begIndex) {
        if (nextIsectPoint == nil) {
          nextIsectPoint = point;
        }
        else if (begIndex < [nextIsectPoint begIndexWithBOOL:isCurrentArea]) {
          nextIsectPoint = point;
        }
      }
    }
  }
  return (nextIsectPoint != nil) ? nextIsectPoint : firstIsectPoint;
}

- (PythagorasFIntersectPoint *)prevIntersectPointWithPythagorasFIntersectPointArray:(IOSObjectArray *)iPoints
                                                      withPythagorasFIntersectPoint:(PythagorasFIntersectPoint *)isectPoint
                                                                           withBOOL:(BOOL)isCurrentArea {
  int begIndex = [((PythagorasFIntersectPoint *) NIL_CHK(isectPoint)) begIndexWithBOOL:isCurrentArea];
  if (begIndex < 0) {
    return ((PythagorasFIntersectPoint *) [((IOSObjectArray *) NIL_CHK(iPoints)) objectAtIndex:[JavaLangMath absWithInt:begIndex] - 1]);
  }
  PythagorasFIntersectPoint *firstIsectPoint = nil;
  PythagorasFIntersectPoint *predIsectPoint = nil;
  {
    IOSObjectArray *a__ = iPoints;
    int n__ = (int) [((IOSObjectArray *) NIL_CHK(a__)) count];
    for (int i__ = 0; i__ < n__; i__++) {
      PythagorasFIntersectPoint *point = ((PythagorasFIntersectPoint *) [((IOSObjectArray *) NIL_CHK(a__)) objectAtIndex:i__]);
      int endIndex = [((PythagorasFIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:isCurrentArea];
      if (endIndex >= 0) {
        if (firstIsectPoint == nil) {
          firstIsectPoint = point;
        }
        else if (endIndex < [firstIsectPoint endIndexWithBOOL:isCurrentArea]) {
          firstIsectPoint = point;
        }
      }
      if (endIndex <= begIndex) {
        if (predIsectPoint == nil) {
          predIsectPoint = point;
        }
        else if (endIndex > [predIsectPoint endIndexWithBOOL:isCurrentArea]) {
          predIsectPoint = point;
        }
      }
    }
  }
  return (predIsectPoint != nil) ? predIsectPoint : firstIsectPoint;
}

- (int)includeCoordsAndRulesWithInt:(int)offset
                            withInt:(int)length
           withJavaLangIntegerArray:(IOSIntArray *)rules
           withJavaLangIntegerArray:(IOSIntArray *)offsets
           withJavaLangIntegerArray:(IOSIntArray *)resultRules
           withJavaLangIntegerArray:(IOSIntArray *)resultOffsets
             withJavaLangFloatArray:(IOSFloatArray *)resultCoords
             withJavaLangFloatArray:(IOSFloatArray *)coords
                            withInt:(int)resultRulesPos
                            withInt:(int)resultCoordPos
      withPythagorasFIntersectPoint:(PythagorasFIntersectPoint *)point
                           withBOOL:(BOOL)isCurrentArea
                           withBOOL:(BOOL)way
                            withInt:(int)operation {
  IOSFloatArray *temp = [[[IOSFloatArray alloc] initWithLength:8 * length] autorelease];
  int coordsCount = 0;
  BOOL isMoveIndex = YES;
  BOOL isMoveLength = YES;
  BOOL additional = NO;
  if (length <= offset) {
    for (int i = resultRulesPos; i < resultRulesPos + 1; i++) {
      [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:i withInt:PythagorasFPathIterator_SEG_LINETO];
    }
  }
  else {
    int j = resultRulesPos;
    for (int i = offset; i < length; i++) {
      [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:j++ withInt:PythagorasFPathIterator_SEG_LINETO];
    }
  }
  if ((length == offset) && (([((IOSIntArray *) NIL_CHK(rules)) intAtIndex:offset] == PythagorasFPathIterator_SEG_QUADTO) || ([((IOSIntArray *) NIL_CHK(rules)) intAtIndex:offset] == PythagorasFPathIterator_SEG_CUBICTO))) {
    length++;
    additional = YES;
  }
  for (int i = offset; i < length; i++) {
    int index = [((IOSIntArray *) NIL_CHK(offsets)) intAtIndex:i];
    if (!isMoveIndex) {
      index -= 2;
    }
    if (!isMoveLength) {
      length++;
      isMoveLength = YES;
    }
    {
      BOOL isLeft;
      IOSFloatArray *coefs;
      switch ([((IOSIntArray *) NIL_CHK(rules)) intAtIndex:i]) {
        case PythagorasFPathIterator_SEG_MOVETO:
        isMoveIndex = NO;
        isMoveLength = NO;
        break;
        case PythagorasFPathIterator_SEG_LINETO:
        case PythagorasFPathIterator_SEG_CLOSE:
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_LINETO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos + 2];
        isLeft = [PythagorasFCrossingHelper compareWithFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index] withFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index + 1] withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) x] withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) y]] > 0;
        if (way || !isLeft) {
          [((IOSFloatArray *) NIL_CHK(temp)) replaceFloatAtIndex:coordsCount++ withFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index]];
          [((IOSFloatArray *) NIL_CHK(temp)) replaceFloatAtIndex:coordsCount++ withFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index + 1]];
        }
        break;
        case PythagorasFPathIterator_SEG_QUADTO:
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_QUADTO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos + 4];
        coefs = [IOSFloatArray arrayWithFloats:(float[]){ [((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index - 2], [((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index - 1], [((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index], [((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index + 1], [((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index + 2], [((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index + 3] } count:6];
        isLeft = [PythagorasFCrossingHelper compareWithFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index - 2] withFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index - 1] withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) x] withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) y]] > 0;
        if ((!additional) && (operation == 0 || operation == 2)) {
          isLeft = !isLeft;
          way = NO;
        }
        [PythagorasFGeometryUtil subQuadWithJavaLangFloatArray:coefs withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) paramWithBOOL:isCurrentArea] withBOOL:isLeft];
        if (way || isLeft) {
          [((IOSFloatArray *) NIL_CHK(temp)) replaceFloatAtIndex:coordsCount++ withFloat:[((IOSFloatArray *) NIL_CHK(coefs)) floatAtIndex:2]];
          [((IOSFloatArray *) NIL_CHK(temp)) replaceFloatAtIndex:coordsCount++ withFloat:[((IOSFloatArray *) NIL_CHK(coefs)) floatAtIndex:3]];
        }
        else {
          [JavaLangSystem arraycopyWithId:coefs withInt:2 withId:temp withInt:coordsCount withInt:4];
          coordsCount += 4;
        }
        break;
        case PythagorasFPathIterator_SEG_CUBICTO:
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasFPathIterator_SEG_CUBICTO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos + 6];
        coefs = [IOSFloatArray arrayWithFloats:(float[]){ [((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index - 2], [((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index - 1], [((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index], [((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index + 1], [((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index + 2], [((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index + 3], [((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index + 4], [((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index + 5] } count:8];
        isLeft = [PythagorasFCrossingHelper compareWithFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index - 2] withFloat:[((IOSFloatArray *) NIL_CHK(coords)) floatAtIndex:index - 1] withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) x] withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) y]] > 0;
        [PythagorasFGeometryUtil subCubicWithJavaLangFloatArray:coefs withFloat:[((PythagorasFIntersectPoint *) NIL_CHK(point)) paramWithBOOL:isCurrentArea] withBOOL:!isLeft];
        if (isLeft) {
          [JavaLangSystem arraycopyWithId:coefs withInt:2 withId:temp withInt:coordsCount withInt:6];
          coordsCount += 6;
        }
        else {
          [JavaLangSystem arraycopyWithId:coefs withInt:2 withId:temp withInt:coordsCount withInt:4];
          coordsCount += 4;
        }
        break;
      }
    }
  }
  if (operation == 2 && !isCurrentArea && coordsCount > 2) {
    [self reverseCopyWithJavaLangFloatArray:temp];
    [JavaLangSystem arraycopyWithId:temp withInt:0 withId:resultCoords withInt:resultCoordPos withInt:coordsCount];
  }
  else {
    [JavaLangSystem arraycopyWithId:temp withInt:0 withId:resultCoords withInt:resultCoordPos withInt:coordsCount];
  }
  return (resultCoordPos + coordsCount);
}

- (void)copy__WithPythagorasFArea:(PythagorasFArea *)src
              withPythagorasFArea:(PythagorasFArea *)dst OBJC_METHOD_FAMILY_NONE {
  ((PythagorasFArea *) NIL_CHK(dst)).coordsSize = ((PythagorasFArea *) NIL_CHK(src)).coordsSize;
  ((PythagorasFArea *) NIL_CHK(dst)).coords = [PythagorasUtilPlatform cloneWithJavaLangFloatArray:((PythagorasFArea *) NIL_CHK(src)).coords];
  ((PythagorasFArea *) NIL_CHK(dst)).rulesSize = ((PythagorasFArea *) NIL_CHK(src)).rulesSize;
  ((PythagorasFArea *) NIL_CHK(dst)).rules = [PythagorasUtilPlatform cloneWithJavaLangIntegerArray:((PythagorasFArea *) NIL_CHK(src)).rules];
  ((PythagorasFArea *) NIL_CHK(dst)).moveToCount = ((PythagorasFArea *) NIL_CHK(src)).moveToCount;
  ((PythagorasFArea *) NIL_CHK(dst)).offsets = [PythagorasUtilPlatform cloneWithJavaLangIntegerArray:((PythagorasFArea *) NIL_CHK(src)).offsets];
}

- (int)containsExactWithFloat:(float)x
                    withFloat:(float)y {
  id<PythagorasFPathIterator> pi = [self pathIteratorWithPythagorasFTransform:nil];
  int crossCount = [PythagorasFCrossing crossPathWithPythagorasFPathIterator:pi withFloat:x withFloat:y];
  if ([PythagorasFCrossing isInsideEvenOddWithInt:crossCount]) {
    return 1;
  }
  IOSFloatArray *segmentCoords = [[[IOSFloatArray alloc] initWithLength:6] autorelease];
  IOSFloatArray *resultPoints = [[[IOSFloatArray alloc] initWithLength:6] autorelease];
  int rule;
  float curX = -1;
  float curY = -1;
  float moveX = -1;
  float moveY = -1;
  for (pi = [self pathIteratorWithPythagorasFTransform:nil]; ![((id<PythagorasFPathIterator>) NIL_CHK(pi)) isDone]; [((id<PythagorasFPathIterator>) NIL_CHK(pi)) next]) {
    rule = [((id<PythagorasFPathIterator>) NIL_CHK(pi)) currentSegmentWithJavaLangFloatArray:segmentCoords];
    switch (rule) {
      case PythagorasFPathIterator_SEG_MOVETO:
      moveX = curX = [((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:0];
      moveY = curY = [((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:1];
      break;
      case PythagorasFPathIterator_SEG_LINETO:
      if ([PythagorasFGeometryUtil intersectLinesWithFloat:curX withFloat:curY withFloat:[((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:1] withFloat:x withFloat:y withFloat:x withFloat:y withJavaLangFloatArray:resultPoints] != 0) {
        return 0;
      }
      curX = [((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:0];
      curY = [((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:1];
      break;
      case PythagorasFPathIterator_SEG_QUADTO:
      if ([PythagorasFGeometryUtil intersectLineAndQuadWithFloat:x withFloat:y withFloat:x withFloat:y withFloat:curX withFloat:curY withFloat:[((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:3] withJavaLangFloatArray:resultPoints] > 0) {
        return 0;
      }
      curX = [((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:2];
      curY = [((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:3];
      break;
      case PythagorasFPathIterator_SEG_CUBICTO:
      if ([PythagorasFGeometryUtil intersectLineAndCubicWithFloat:x withFloat:y withFloat:x withFloat:y withFloat:curX withFloat:curY withFloat:[((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:4] withFloat:[((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:5] withJavaLangFloatArray:resultPoints] > 0) {
        return 0;
      }
      curX = [((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:4];
      curY = [((IOSFloatArray *) NIL_CHK(segmentCoords)) floatAtIndex:5];
      break;
      case PythagorasFPathIterator_SEG_CLOSE:
      if ([PythagorasFGeometryUtil intersectLinesWithFloat:curX withFloat:curY withFloat:moveX withFloat:moveY withFloat:x withFloat:y withFloat:x withFloat:y withJavaLangFloatArray:resultPoints] != 0) {
        return 0;
      }
      curX = moveX;
      curY = moveY;
      break;
    }
  }
  return -1;
}

- (void)reverseCopyWithJavaLangFloatArray:(IOSFloatArray *)coords {
  IOSFloatArray *temp = [[[IOSFloatArray alloc] initWithLength:(int) [((IOSFloatArray *) NIL_CHK(coords)) count]] autorelease];
  [JavaLangSystem arraycopyWithId:coords withInt:0 withId:temp withInt:0 withInt:(int) [((IOSFloatArray *) NIL_CHK(coords)) count]];
  for (int i = 0; i < (int) [((IOSFloatArray *) NIL_CHK(coords)) count]; ) {
    [((IOSFloatArray *) NIL_CHK(coords)) replaceFloatAtIndex:i withFloat:[((IOSFloatArray *) NIL_CHK(temp)) floatAtIndex:(int) [((IOSFloatArray *) NIL_CHK(coords)) count] - i - 2]];
    [((IOSFloatArray *) NIL_CHK(coords)) replaceFloatAtIndex:i + 1 withFloat:[((IOSFloatArray *) NIL_CHK(temp)) floatAtIndex:(int) [((IOSFloatArray *) NIL_CHK(coords)) count] - i - 1]];
    i = i + 2;
  }
}

- (float)areaBoundsSquare {
  PythagorasFRectangle *bounds = [self bounds];
  return [((PythagorasFRectangle *) NIL_CHK(bounds)) height] * [((PythagorasFRectangle *) NIL_CHK(bounds)) width];
}

- (BOOL)isVertexWithFloat:(float)x
                withFloat:(float)y {
  for (int i = 0; i < coordsSize_; ) {
    if (x == [((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:i++] && y == [((IOSFloatArray *) NIL_CHK(coords_)) floatAtIndex:i++]) {
      return YES;
    }
  }
  return NO;
}

+ (IOSFloatArray *)adjustSizeWithJavaLangFloatArray:(IOSFloatArray *)array
                                            withInt:(int)newSize {
  if (newSize <= (int) [((IOSFloatArray *) NIL_CHK(array)) count]) {
    return array;
  }
  IOSFloatArray *newArray = [[[IOSFloatArray alloc] initWithLength:2 * newSize] autorelease];
  [JavaLangSystem arraycopyWithId:array withInt:0 withId:newArray withInt:0 withInt:(int) [((IOSFloatArray *) NIL_CHK(array)) count]];
  return newArray;
}

+ (IOSIntArray *)adjustSizeWithJavaLangIntegerArray:(IOSIntArray *)array
                                            withInt:(int)newSize {
  if (newSize <= (int) [((IOSIntArray *) NIL_CHK(array)) count]) {
    return array;
  }
  IOSIntArray *newArray = [[[IOSIntArray alloc] initWithLength:2 * newSize] autorelease];
  [JavaLangSystem arraycopyWithId:array withInt:0 withId:newArray withInt:0 withInt:(int) [((IOSIntArray *) NIL_CHK(array)) count]];
  return newArray;
}

- (id)copyWithZone:(NSZone *)zone {
  return [[self clone] retain];
}

- (void)dealloc {
  JreOperatorRetainedAssign(&offsets_, self, nil);
  JreOperatorRetainedAssign(&rules_, self, nil);
  JreOperatorRetainedAssign(&coords_, self, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  PythagorasFArea *typedCopy = (PythagorasFArea *) copy;
  typedCopy.coords = coords_;
  typedCopy.coordsSize = coordsSize_;
  typedCopy.rules = rules_;
  typedCopy.rulesSize = rulesSize_;
  typedCopy.offsets = offsets_;
  typedCopy.moveToCount = moveToCount_;
  typedCopy.isPolygonal_ = isPolygonal__;
}

@end
@implementation PythagorasFArea_AreaPathIterator

- (PythagorasFArea *)this$0 {
  return this$0_;
}
- (void)setThis$0:(PythagorasFArea *)this$0 {
  JreOperatorRetainedAssign(&this$0_, self, this$0);
}
@synthesize this$0 = this$0_;
- (id<PythagorasFTransform>)transform {
  return transform_;
}
- (void)setTransform:(id<PythagorasFTransform>)transform {
  JreOperatorRetainedAssign(&transform_, self, transform);
}
@synthesize transform = transform_;
@synthesize curRuleIndex = curRuleIndex_;
@synthesize curCoordIndex = curCoordIndex_;

- (id)initWithPythagorasFArea:(PythagorasFArea *)outer$
     withPythagorasFTransform:(id<PythagorasFTransform>)t {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&this$0_, self, outer$);
    curRuleIndex_ = 0;
    curCoordIndex_ = 0;
    self.transform = t;
  }
  return self;
}

- (int)windingRule {
  return PythagorasFPathIterator_WIND_EVEN_ODD;
}

- (BOOL)isDone {
  return curRuleIndex_ >= this$0_.rulesSize;
}

- (void)next {
  switch ([((IOSIntArray *) NIL_CHK(this$0_.rules)) intAtIndex:curRuleIndex_]) {
    case PythagorasFPathIterator_SEG_MOVETO:
    case PythagorasFPathIterator_SEG_LINETO:
    curCoordIndex_ += 2;
    break;
    case PythagorasFPathIterator_SEG_QUADTO:
    curCoordIndex_ += 4;
    break;
    case PythagorasFPathIterator_SEG_CUBICTO:
    curCoordIndex_ += 6;
    break;
  }
  curRuleIndex_++;
}

- (int)currentSegmentWithJavaLangFloatArray:(IOSFloatArray *)c {
  if ([self isDone]) {
    @throw [[[JavaUtilNoSuchElementException alloc] initWithNSString:@"Iterator out of bounds"] autorelease];
  }
  int count = 0;
  switch ([((IOSIntArray *) NIL_CHK(this$0_.rules)) intAtIndex:curRuleIndex_]) {
    case PythagorasFPathIterator_SEG_CUBICTO:
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:4 withFloat:[((IOSFloatArray *) NIL_CHK(this$0_.coords)) floatAtIndex:curCoordIndex_ + 4]];
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:5 withFloat:[((IOSFloatArray *) NIL_CHK(this$0_.coords)) floatAtIndex:curCoordIndex_ + 5]];
    count = 1;
    case PythagorasFPathIterator_SEG_QUADTO:
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:2 withFloat:[((IOSFloatArray *) NIL_CHK(this$0_.coords)) floatAtIndex:curCoordIndex_ + 2]];
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:3 withFloat:[((IOSFloatArray *) NIL_CHK(this$0_.coords)) floatAtIndex:curCoordIndex_ + 3]];
    count += 1;
    case PythagorasFPathIterator_SEG_MOVETO:
    case PythagorasFPathIterator_SEG_LINETO:
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:0 withFloat:[((IOSFloatArray *) NIL_CHK(this$0_.coords)) floatAtIndex:curCoordIndex_]];
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:1 withFloat:[((IOSFloatArray *) NIL_CHK(this$0_.coords)) floatAtIndex:curCoordIndex_ + 1]];
    count += 1;
  }
  if (transform_ != nil) {
    [transform_ transformWithJavaLangFloatArray:c withInt:0 withJavaLangFloatArray:c withInt:0 withInt:count];
  }
  return [((IOSIntArray *) NIL_CHK(this$0_.rules)) intAtIndex:curRuleIndex_];
}

- (void)dealloc {
  JreOperatorRetainedAssign(&transform_, self, nil);
  JreOperatorRetainedAssign(&this$0_, self, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  PythagorasFArea_AreaPathIterator *typedCopy = (PythagorasFArea_AreaPathIterator *) copy;
  typedCopy.this$0 = this$0_;
  typedCopy.transform = transform_;
  typedCopy.curRuleIndex = curRuleIndex_;
  typedCopy.curCoordIndex = curCoordIndex_;
}

@end
