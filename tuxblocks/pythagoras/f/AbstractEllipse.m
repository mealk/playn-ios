//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: pythagoras/f/AbstractEllipse.java
//
//  Created by Thomas on 7/1/13.
//

#import "Ellipse.h"
#import "FloatMath.h"
#import "IEllipse.h"
#import "IOSFloatArray.h"
#import "IOSObjectArray.h"
#import "IRectangularShape.h"
#import "PathIterator.h"
#import "RectangularShape.h"
#import "Transform.h"
#import "java/util/NoSuchElementException.h"
#import "AbstractEllipse.h"

@implementation PythagorasFAbstractEllipse

static float PythagorasFAbstractEllipse_U_;
static IOSObjectArray * PythagorasFAbstractEllipse_POINTS_;

+ (float)U {
  return PythagorasFAbstractEllipse_U_;
}

+ (IOSObjectArray *)POINTS {
  return PythagorasFAbstractEllipse_POINTS_;
}

- (PythagorasFEllipse *)clone {
  return [[[PythagorasFEllipse alloc] initWithFloat:[self x] withFloat:[self y] withFloat:[self width] withFloat:[self height]] autorelease];
}

- (BOOL)containsWithFloat:(float)px
                withFloat:(float)py {
  if ([self isEmpty]) return NO;
  float a = (px - [self x]) / [self width] - 0.5f;
  float b = (py - [self y]) / [self height] - 0.5f;
  return a * a + b * b < 0.25f;
}

- (BOOL)containsWithFloat:(float)rx
                withFloat:(float)ry
                withFloat:(float)rw
                withFloat:(float)rh {
  if ([self isEmpty] || rw <= 0.0f || rh <= 0.0f) return NO;
  float rx1 = rx, ry1 = ry, rx2 = rx + rw, ry2 = ry + rh;
  return [self containsWithFloat:rx1 withFloat:ry1] && [self containsWithFloat:rx2 withFloat:ry1] && [self containsWithFloat:rx2 withFloat:ry2] && [self containsWithFloat:rx1 withFloat:ry2];
}

- (BOOL)intersectsWithFloat:(float)rx
                  withFloat:(float)ry
                  withFloat:(float)rw
                  withFloat:(float)rh {
  if ([self isEmpty] || rw <= 0.0f || rh <= 0.0f) return NO;
  float cx = [self x] + [self width] / 2.0f;
  float cy = [self y] + [self height] / 2.0f;
  float rx1 = rx, ry1 = ry, rx2 = rx + rw, ry2 = ry + rh;
  float nx = cx < rx1 ? rx1 : (cx > rx2 ? rx2 : cx);
  float ny = cy < ry1 ? ry1 : (cy > ry2 ? ry2 : cy);
  return [self containsWithFloat:nx withFloat:ny];
}

- (id<PythagorasFPathIterator>)pathIteratorWithPythagorasFTransform:(id<PythagorasFTransform>)at {
  return [[[PythagorasFAbstractEllipse_Iterator alloc] initWithPythagorasFIEllipse:self withPythagorasFTransform:at] autorelease];
}

- (float)height {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (float)width {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (float)x {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (float)y {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)init {
  return [super init];
}

+ (void)initialize {
  if (self == [PythagorasFAbstractEllipse class]) {
    PythagorasFAbstractEllipse_U_ = 2.0f / 3.0f * ([PythagorasFFloatMath sqrtWithFloat:2] - 1.0f);
    JreOperatorRetainedAssign(&PythagorasFAbstractEllipse_POINTS_, self, [IOSObjectArray arrayWithObjects:(id[]){ [IOSFloatArray arrayWithFloats:(float[]){ 1.0f, 0.5f + PythagorasFAbstractEllipse_U_, 0.5f + PythagorasFAbstractEllipse_U_, 1.0f, 0.5f, 1.0f } count:6], [IOSFloatArray arrayWithFloats:(float[]){ 0.5f - PythagorasFAbstractEllipse_U_, 1.0f, 0.0f, 0.5f + PythagorasFAbstractEllipse_U_, 0.0f, 0.5f } count:6], [IOSFloatArray arrayWithFloats:(float[]){ 0.0f, 0.5f - PythagorasFAbstractEllipse_U_, 0.5f - PythagorasFAbstractEllipse_U_, 0.0f, 0.5f, 0.0f } count:6], [IOSFloatArray arrayWithFloats:(float[]){ 0.5f + PythagorasFAbstractEllipse_U_, 0.0f, 1.0f, 0.5f - PythagorasFAbstractEllipse_U_, 1.0f, 0.5f } count:6] } count:4 type:[IOSClass classWithClass:[IOSFloatArray class]]]);
  }
}

- (id)copyWithZone:(NSZone *)zone {
  return [[self clone] retain];
}

- (void)dealloc {
  [super dealloc];
}

@end
@implementation PythagorasFAbstractEllipse_Iterator

@synthesize x = x_;
@synthesize y = y_;
@synthesize width = width_;
@synthesize height = height_;
- (id<PythagorasFTransform>)t {
  return t_;
}
- (void)setT:(id<PythagorasFTransform>)t {
  JreOperatorRetainedAssign(&t_, self, t);
}
@synthesize t = t_;
@synthesize index = index_;

- (id)initWithPythagorasFIEllipse:(id<PythagorasFIEllipse>)e
         withPythagorasFTransform:(id<PythagorasFTransform>)t {
  if ((self = [super init])) {
    self.x = [((id<PythagorasFIEllipse>) NIL_CHK(e)) x];
    self.y = [((id<PythagorasFIEllipse>) NIL_CHK(e)) y];
    self.width = [((id<PythagorasFIEllipse>) NIL_CHK(e)) width];
    self.height = [((id<PythagorasFIEllipse>) NIL_CHK(e)) height];
    self.t = t;
    if (width_ < 0.0f || height_ < 0.0f) {
      index_ = 6;
    }
  }
  return self;
}

- (int)windingRule {
  return PythagorasFPathIterator_WIND_NON_ZERO;
}

- (BOOL)isDone {
  return index_ > 5;
}

- (void)next {
  index_++;
}

- (int)currentSegmentWithJavaLangFloatArray:(IOSFloatArray *)coords {
  if ([self isDone]) {
    @throw [[[JavaUtilNoSuchElementException alloc] initWithNSString:@"Iterator out of bounds"] autorelease];
  }
  if (index_ == 5) {
    return PythagorasFPathIterator_SEG_CLOSE;
  }
  int type;
  int count;
  if (index_ == 0) {
    type = PythagorasFPathIterator_SEG_MOVETO;
    count = 1;
    IOSFloatArray *p = ((IOSFloatArray *) [((IOSObjectArray *) NIL_CHK([PythagorasFAbstractEllipse POINTS])) objectAtIndex:3]);
    [((IOSFloatArray *) NIL_CHK(coords)) replaceFloatAtIndex:0 withFloat:x_ + [((IOSFloatArray *) NIL_CHK(p)) floatAtIndex:4] * width_];
    [((IOSFloatArray *) NIL_CHK(coords)) replaceFloatAtIndex:1 withFloat:y_ + [((IOSFloatArray *) NIL_CHK(p)) floatAtIndex:5] * height_];
  }
  else {
    type = PythagorasFPathIterator_SEG_CUBICTO;
    count = 3;
    IOSFloatArray *p = ((IOSFloatArray *) [((IOSObjectArray *) NIL_CHK([PythagorasFAbstractEllipse POINTS])) objectAtIndex:index_ - 1]);
    int j = 0;
    for (int i = 0; i < 3; i++) {
      [((IOSFloatArray *) NIL_CHK(coords)) replaceFloatAtIndex:j withFloat:x_ + [((IOSFloatArray *) NIL_CHK(p)) floatAtIndex:j++] * width_];
      [((IOSFloatArray *) NIL_CHK(coords)) replaceFloatAtIndex:j withFloat:y_ + [((IOSFloatArray *) NIL_CHK(p)) floatAtIndex:j++] * height_];
    }
  }
  if (t_ != nil) {
    [t_ transformWithJavaLangFloatArray:coords withInt:0 withJavaLangFloatArray:coords withInt:0 withInt:count];
  }
  return type;
}

- (void)dealloc {
  JreOperatorRetainedAssign(&t_, self, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  PythagorasFAbstractEllipse_Iterator *typedCopy = (PythagorasFAbstractEllipse_Iterator *) copy;
  typedCopy.x = x_;
  typedCopy.y = y_;
  typedCopy.width = width_;
  typedCopy.height = height_;
  typedCopy.t = t_;
  typedCopy.index = index_;
}

@end
